var documenterSearchIndex = {"docs":
[{"location":"vpalm/api/#XPalm.VPalm-submodule-API","page":"XPalm.VPalm API","title":"XPalm.VPalm submodule API","text":"","category":"section"},{"location":"vpalm/api/#XPalm.VPalm.AbstractGeometryModel","page":"XPalm.VPalm API","title":"XPalm.VPalm.AbstractGeometryModel","text":"geometry process abstract model. \n\nAll models implemented to simulate the geometry process must be a subtype of this type, e.g.  struct MyGeometryModel <: AbstractGeometryModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractGeometryModel)\n\n\n\n\n\n","category":"type"},{"location":"vpalm/api/#XPalm.VPalm.LeafGeometryModel","page":"XPalm.VPalm API","title":"XPalm.VPalm.LeafGeometryModel","text":"LeafGeometryModel(;vpalm_parameters, rng=Random.MersenneTwister())\n\nA PlantSimEngine model that builds the 3D geometry for a leaf, including the petiole, rachis, and leaflets. This model operates at the phytomer scale and modifies the MTG directly.\n\nArguments\n\nvpalm_parameters::Dict{String,Any}: VPalm model parameters.\nrng::Random.AbstractRNG: Random number generator for stochastic processes.\n\nInputs\n\nheight_internodes: Internode height (from plantsimengine_status)\nradius_internodes: Internode radius (from plantsimengine_status)  \nbiomass_leaves: Leaf biomass (from plantsimengine_status)\nrank_leaves: Leaf rank (from plantsimengine_status)\n\nOutputs\n\nThis model has no outputs as it modifies the MTG directly by adding geometric properties and child nodes.\n\nNotes\n\nThe model requires access to the VPalm parameters via the parameters dictionary under the \"vpalm\" key.\n\n\n\n\n\n","category":"type"},{"location":"vpalm/api/#PlantSimEngine.run!-Tuple{XPalm.VPalm.LeafGeometryModel, Vararg{Any, 5}}","page":"XPalm.VPalm API","title":"PlantSimEngine.run!","text":"run!(model, models, status, meteo, constants, node)\n\nBuilds the 3D geometry for a leaf by adding internode properties and creating child nodes for petiole, rachis, and leaflets.\n\nArguments\n\nmodel::LeafGeometryModel: The leaf geometry model\nmodels: A ModelList struct holding the parameters for the model\nstatus: The status of the model with inputs (height, radius, biomass, rank)\nmeteo: Meteorology structure (not used by this model)\nconstants: Physical constants (not used by this model)\nnode: MTG node of the phytomer\n\nNotes\n\nThe model expects node to be the phytomer MTG node and accesses VPalm parameters from model.vpalm_parameters.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.add_geometry!-NTuple{4, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.add_geometry!","text":"add_geometry!(\n    mtg, refmesh_cylinder, refmesh_snag, refmesh_plane;\n    snag_width=0.20u\"m\", # see defaultOrthotropyAttribute in the trunk in the java implementation\n    snag_height=0.15u\"m\",\n    snag_length=3.0u\"m\",\n)\n\nAdds geometry to the MTG (Multiscale Tree Graph) for the oil palm plant architecture, i.e. compute the meshes.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.add_leaflet_geometry!-NTuple{8, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.add_leaflet_geometry!","text":"add_leaflet_geometry!(\n    leaflet_node,\n    internode_width,\n    internode_height,\n    rachis_position,\n    rachis_orientation,\n    rachis_rotation,\n    stem_bending,\n    refmesh_plane\n)\n\nCreate the leaflet geometry based on its segments.\n\nArguments\n\nleaflet_node: The MTG node of the leaflet\ninternode_width: Width of the internode (used for positioning)\ninternode_height: Height of the internode (used for positioning)\nrachis_position: Position of the rachis section where the leaflet is attached\nrachis_orientation: Orientation angles [zenithal, azimuthal, torsion] of the rachis section\nrachis_rotation: Rotation of the rachis due to phyllotaxy (degrees)\nstem_bending: Bending of the stem (degrees)\nrefmesh_plane: Reference mesh used for the planar leaflet segments\n\nReturns\n\nNothing (the geometry is added directly to the leaflet node and its segments)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.add_section_geometry!","page":"XPalm.VPalm API","title":"XPalm.VPalm.add_section_geometry!","text":"add_section_geometry!(\n    node, internode_width, internode_height, internode_phyllotaxy, stem_bending, \n    refmesh_cylinder, position_section=Ref(Meshes.Point(0.0, 0.0, 0.0)), angles=[0.0, 0.0, 0.0],\n    type::String,\n)\n\nCreate the petiole/rachis sections geometry based on their dimensions.\n\nArguments\n\nnode: the MTG node of the petiole/rachis\nrefmesh_cylinder: the reference mesh used for a cylinder (PlantGeom.RefMesh)\ninternode_width: the width of the internode on the stipe (m)\ninternode_height: the height of the internode on the stipe (m)\ninternode_phyllotaxy: the phyllotaxy of the internode on the stipe (°)\nstem_bending: the bending of the stipe (°)\ntype::String: the type of the section (\"PetioleSegment\" or \"RachisSegment\")\nposition_section=Ref(Meshes.Point(0.0, 0.0, 0.0)): the position of the section relative to the first one.\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.bend-NTuple{16, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.bend","text":"bend(\n    type, width_bend, height_bend, init_torsion, x, y, z, mass_rachis, mass_leaflets_right, mass_leaflets_left,\n    distance_application, elastic_modulus, shear_modulus, step, npoints, nsegments;\n    all_points=false,\n    angle_max=deg2rad(21),\n    force=true,\n    verbose=true\n)\n\nCompute the deformation of the rachis by applying both bending and torsion.\n\nArguments\n\ntype: Vector of section types (1: triangle bottom, 2: rectangle, 3: triangle top, 4: ellipse, 5: circle).\nwidth_bend: Vector of segment section widths (m).\nheight_bend: Vector of segment section heights (m).\ninit_torsion: Vector of initial torsion angles (degrees).\nx: Vector of x coordinates of the segments.\ny: Vector of y coordinates of the segments.\nz: Vector of z coordinates of the segments.\nmass_rachis: Vector of rachis segment masses (kg).\nmass_leaflets_right: Vector of leaflet masses carried by the segment, on the right side (kg).\nmass_leaflets_left: Vector of leaflet masses carried by the segment, on the left side (kg).\ndistance_application: Vector of application distances for the left and right weights (m).\nelastic_modulus: Vector of elasticity moduli (bending, MPa).\nshear_modulus: Vector of shear moduli (torsion, MPa).\nstep: Length of the segments that discretize the object (m).\nnpoints: Number of points used in the grid discretizing the section.\nnsegments: Number of segments dividing the rachis to compute the torsion and bending.\nall_points=false: return all points used in the computation (true), or only the input points corresponding to x, y and z coordinates (false, default).\nangle_max=deg2rad(21): Maximum angle for testing the small displacement hypothesis (radians).\nforce=true: Check if verify the small displacements hypothesis and bounds the values to be at maximum angle_max\nverbose=true: Provide information during computation.\n\nReturns\n\nNamed tuple with geometrical fields describing the rachis bended and with torsion applied\n\nx: x coordinates of the points.\ny: y coordinates of the points.\nz: z coordinates of the points.\nlength: length of the segments.\nangle_xy: angle between the xy-plan and the segment.\nangle_xz: angle between the xz-plan and the segment.\ntorsion: torsion angle of the segment.\n\nAll these fields are vectors of the same length as the input vectors (i.e. number of segments).\n\nDetails\n\nThe bending and torsion are applied to the sections of the rachis defined by 5 segments.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.beta_distribution_norm-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.beta_distribution_norm","text":"beta_distribution_norm(x, xm, ym)\n\nCalculate the normalized beta distribution value at point x. This is the exact implementation from the Java version.\n\nArguments\n\nx: Position [0 to 1].\nxm: Mode of the beta distribution.\nym: Maximum value of the beta distribution.\n\nReturns\n\nNormalized beta distribution value.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.beta_distribution_norm_integral-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.beta_distribution_norm_integral","text":"beta_distribution_norm_integral(xm, ym)\n\nCalculate the integral (area) of the normalized beta distribution. Equivalent to betaDistributionNormIntegral in the Java version.\n\nArguments\n\nxm: Mode of the beta distribution.\nym: Value of the function at the mode.\n\nReturns\n\nApproximate area under the beta distribution curve.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.biomechanical_properties_rachis-NTuple{21, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.biomechanical_properties_rachis","text":"biomechanical_properties_rachis(\n    rachis_twist_initial_angle, rachis_twist_initial_angle_sdp,\n    elastic_modulus, shear_modulus, rachis_length,\n    leaflet_length_at_b_intercept, leaflet_length_at_b_slope, relative_position_bpoint,\n    relative_position_bpoint_sd, relative_length_first_leaflet, relative_length_last_leaflet, relative_position_leaflet_max_length,\n    rachis_fresh_weight, rank, height_cpoint, zenithal_cpoint_angle, nb_sections,\n    height_rachis_tappering,\n    points, iterations, angle_max;\n    verbose, rng\n)\n\nUse of the biomechanical model to compute the properties of the rachis.\n\nArguments\n\nrachis_twist_initial_angle: initial twist angle of the rachis (°)\nrachis_twist_initial_angle_sdp: standard deviation of the initial twist angle of the rachis (°)\nelastic_modulus: elastic modulus of the rachis (Pa)\nshear_modulus: shear modulus of the rachis (Pa)\nrachis_length: length of the rachis (m)\nleaflet_length_at_b_intercept: intercept of the linear function for the leaflet length at the B point (m)\nleaflet_length_at_b_slope: slope of the linear function for the leaflet length at the B point (m)\nrelative_position_bpoint: relative position of the B point on the rachis (0: base to 1: tip)\nrelative_position_bpoint_sd: standard deviation of the relative position of the B point on the rachis\nrelative_length_first_leaflet: relative length of the first leaflet on the rachis (0 to 1)\nrelative_length_last_leaflet: relative length of the last leaflet on the rachis (0 to 1)\nrelative_position_leaflet_max_length: relative position of the longest leaflet on the rachis (0.111 to 0.999)\nrachis_fresh_weight: fresh weight of the rachis (kg)\nrank: rank of the rachis\nheight_cpoint: height of the C point (m)\nzenithal_cpoint_angle: zenithal angle of the C point (°)\nnb_sections: number of sections to compute the bending\nheight_rachis_tappering: tappering factor for the rachis height\nnpoints_computed: number of points to compute the bending\niterations: number of iterations to compute the bending\nangle_max: maximum angle to compute the bending (°)\nverbose: display information about the computation (e.g. checks on the units)\nrng: the random number generator\n\nReturns\n\nA named tuple with the following fields:\n\nlength: vector with the length of each segment\npoints_positions: the position of the points along the rachis\nbending: the bending angle of the rachis\ndeviation: the deviation of the rachis (angle in the xz plane)\ntorsion: the torsion of the rachis\nx: the x coordinates of the rachis\ny: the y coordinates of the rachis\nz: the z coordinates of the rachis\n\nDetails\n\nSplit the rachis into 5 segments defined by remarkable points (C, C-B, B, B-A, A). Each segment has a particular shape, a mass, and the leaflets on both sides of the rachis have a mass. Coefficents are used to compute the mass distribution and relative lengths of segments. The rachis is bent using the bend function.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.build_mockup-Tuple{Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.build_mockup","text":"build_mockup(parameters; merge_scale=:leaflet, rng=Random.MersenneTwister(parameters[\"seed\"]))\n\nConstruct a mockup of an oil palm plant architecture using the specified parameters.\n\nArguments\n\nparameters::Dict: Dictionary containing model parameters for the oil palm plant architecture.\nmerge_scale::Symbol: (optional) The scale at which to merge geometry.\n:node: Geometry is not merged, each node has its own mesh (finer scale is leaflet segments).\n:leaflet (default): Geometry is merged at the leaflet level.\n:leaf: All geometry for a leaf is merged into a single mesh.\n:plant: All plant geometry is merged into a single mesh.\nrng: (optional) A random number generator for stochastic processes. Defaults to a Mersenne Twister seeded with the value in parameters[\"seed\"]. If set to nothing, randomness is disabled (useful for testing).\n\nDescription\n\nThe merge_scale argument controls how the geometry is structured within the Multiscale Tree Graph (MTG). The resulting mesh is identical in all cases, but its organization differs.\n\nUsing :leaflet retains the finest detail, with each leaflet having its own mesh. This is best for analyses like light interception at the organ level.\nUsing :leaf or :plant merges geometry into larger components. A single mesh for the whole plant (:plant) is the most performant for rendering, but it prevents querying information for individual organs from the mesh (e.g., which part of the mesh is a given leaflet).\n\nReturns\n\nmtg: An MTG (Multiscale Tree Graph) representing the oil palm plant architecture, including geometry at the specified merge scale.\n\nExample\n\nusing XPalm.VPalm\nfile = joinpath(dirname(dirname(pathof(XPalm))), \"test\", \"references\", \"vpalm-parameter_file.yml\")\nparameters = read_parameters(file)\nmtg = build_mockup(parameters; merge_scale=:plant)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.c_point_angle-NTuple{4, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.c_point_angle","text":"c_point_angle(leaf_rank, cpoint_decli_intercept, cpoint_decli_slope, cpoint_angle_SDP; rng)\n\nCompute the angle at the C point of the leaf.\n\nArguments\n\nleaf_rank: Rank of the leaf\ncpoint_decli_intercept: Intercept of the linear relationship between leaf rank and C point declination\ncpoint_decli_slope: Slope of the linear relationship\ncpoint_angle_SDP: Standard deviation of the C point angle\nrng: Random number generator\n\nReturns\n\nThe zenithal angle at the C point of the leaf (°)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.calculate_segment","page":"XPalm.VPalm API","title":"XPalm.VPalm.calculate_segment","text":"calculate_segment(relative_position, num_segments=10)\n\nCalculate the segment index for a given relative position along the rachis.\n\nArguments\n\nrelative_position: Relative position along the rachis [0 to 1), where 0 is the base and 1 is the tip.\nnum_segments: Number of segments the rachis is divided into (default: 10).\n\nDetails\n\nWe divide the rachis into segments to capture variations in properties along its length. This function:\n\nConverts a continuous relative position (0-1) into a discrete segment index\nEnsures the segment index is within valid bounds (1 to num_segments)\n\nBiological Context\n\nThe palm rachis exhibits changing properties along its length, including:\n\nLeaflet grouping patterns\nLeaflet sizes and angles\n\nDividing the rachis into discrete segments allows the model to represent these gradual changes in a computationally efficient manner. Each segment can have different parameter values that together create the characteristic patterns seen in real palms.\n\nReturns\n\nThe segment index (starts at 1 in Julia).\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.calculate_segment_angles-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.calculate_segment_angles","text":"calculate_segment_angles(young_modulus, initial_angle, leaflet_length, tapering, segment_positions)\n\nCalculate the global angles for each segment of a bent leaflet based on the Young's modulus model.\n\nArguments\n\nyoung_modulus: Value of Young's modulus\ninitial_angle: Initial angle from vertical in radians\nleaflet_length: Total length of the leaflet\ntapering: Tapering factor\nsegment_positions: Array of segment boundary positions (normalized 0-1)\n\nReturns\n\nArray of segment angles in radians\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_leaf_rank","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_leaf_rank","text":"compute_leaf_rank(nb_internodes, index_leaf)\n\nCompute the rank of a leaf based on the total number of internodes and the index of the leaf.\n\nArguments\n\nnb_internodes: The total number of internodes until leaf of rank 1.\nindex_leaf: The index of the leaf.\nleaves_in_sheath: The number of leaves in the sheath, i.e. with rank < 1 (default is 0).\n\nNote\n\nThis is a simple leaf rank, not considering the leaves of rank <= 0.\n\nReturns\n\nThe leaf rank, i.e. 1 for the first opened leaf, 2 for the second leaf, etc.\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.compute_leaflet_type_frequencies-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_leaflet_type_frequencies","text":"compute_leaflet_type_frequencies(leaflet_frequency_high, leaflet_frequency_low)\n\nCompute the frequency of leaflet type within the sub-sections of a rachis.\n\nArguments\n\nleaflet_frequency_high: Vector of frequency values for the +1 leaflet types (high) along the rachis sub-sections.\nleaflet_frequency_low: Vector of frequency values for the -1 leaflet types (low) along the rachis sub-sections..\n\nNote that the length of the two vectors must be the same. It will define how many sub-sections the rachis is divided into for this computation.\n\nReturns\n\nA vector of NamedTuples representing the (;high, medium, low) frequencies for each sub-section.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_number_of_leaflets-NTuple{6, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_number_of_leaflets","text":"compute_number_of_leaflets(rachis_final_length, nb_max, nb_slope, nb_infl, nbLeaflets_SDP; rng)\n\nCompute the number of leaflets based on the logistic function, a standard deviation and a minimum value allowed.\n\nArguments\n\nrachis_final_length: Final length of the rachis (m).\nnb_max: Maximum number of leaflets.\nnb_min: Minimum number of leaflets.\nnb_slope: Slope parameter for the logistic function (leaflet m⁻¹).\nnb_infl: Inflection point parameter for the logistic function (m).\nnbLeaflets_SDP: Standard deviation of the normal distribution for the number of leaflets.\nrng: Random number generator.\n\nReturns\n\nThe computed number of leaflets (integer).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_properties_internode!-NTuple{8, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_properties_internode!","text":"compute_properties_internode!(node, index, nb_internodes, rank, stem_height, stem_diameter, parameters, rng)\n\nComputes the mtg properties of an internode.\n\nArguments\n\nnode: the internode node\nindex: the index of the internode\nnb_internodes: the total number of internodes\nrank: the rank of the internode\nstem_height: the height of the stem (m)\nstem_diameter: the diameter of the stem (m)\nparameters: the parameters of the model\nrng: the random number generator\n\nReturns\n\nThe internode node updated with properties.\n\nDetails\n\nThe internode dimensions are computed based on the dimensions of the stem and the parameters of the model:\n\nwidth: width of the internode (m)\ndiameter: diameter of the internode (m)\nlength: length of the internode (m)\nrank: rank of the internode\nOrthotropy: orthotropy of the internode (set as a constant value)\nXEuler: Euler / phyllotactic angle of the internode (rad)\n\nExamples\n\nusing XPalm.VPalm\nusing Unitful\n\nparameters = VPalm.default_parameters()\nnb_internodes = parameters[\"nb_leaves_emitted\"] + parameters[\"nb_internodes_before_planting\"] # The number of internodes emitted since the seed\n# Plant / Scale 1\nplant = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\n# Stem (& Roots) / Scale 2\nstem = Node(plant, NodeMTG(\"+\", \"Stem\", 1, 2))\ncompute_properties_stem!(stem, parameters, 3.0u\"m\"; rng=rng)\nstem_height = stem[:stem_height]\nstem_diameter = stem[:stem_diameter]\n# Phytomer / Scale 3\nphytomer = Node(stem, NodeMTG(\"/\", \"Phytomer\", 1, 3))\n# Internode & Leaf / Scale 4\ninternode = Node(phytomer, NodeMTG(\"/\", \"Internode\", 1, 4))\ncompute_properties_internode!(internode, 1, nb_internodes, stem_height, stem_diameter, parameters, rng)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_properties_leaf!-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_properties_leaf!","text":"compute_properties_leaf!(node, leaf_rank, final_length, parameters, rng)\n\nCompute the properties of a leaf node:\n\nzenithalinsertionangle: the zenithal insertion angle of the leaf (rad)\nrachis_length: the length of the rachis (m)\nzenithalcpointangle: the zenithal angle at C-point (rad)\n\nArguments\n\nnode: the leaf node\nleaf_rank: the rank of the leaf\nfinal_length: the final length of the leaf (m)\nparameters: the parameters of the model\nrng: the random number generator\n\nReturns\n\nThe leaf node updated with properties.\n\nDetails\n\nThe leaf dimensions are computed based on the dimensions of the stem and the parameters of the model:\n\nzenithalinsertionangle: the zenithal insertion angle of the leaf (rad). Uses the VPalm.leaf_insertion_angle function.\nrachislength: the length of the rachis (m). Uses the `rachisexpansion` function.\nzenithalcpointangle: the zenithal angle at C-point (rad). Uses the c_point_angle function.\n\nExamples\n\nusing XPalm.VPalm\nusing Unitful\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"files\", \"parameter_file.yml\")\nparameters = read_parameters(file)\nnb_internodes = parameters[\"nb_leaves_emitted\"] + parameters[\"nb_internodes_before_planting\"] # The number of internodes emitted since the seed\nnb_leaves_alive = floor(Int, mean_and_sd(parameters[\"nb_leaves_mean\"], parameters[\"nb_leaves_sd\"], rng))\nnb_leaves_alive = min(nb_leaves_alive, nb_internodes)\n# Plant / Scale 1\nplant = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\n# Stem (& Roots) / Scale 2\nstem = Node(plant, NodeMTG(\"+\", \"Stem\", 1, 2))\ncompute_properties_stem!(stem, parameters, 3.0u\"m\"; rng=rng)\nstem_height = stem[:stem_height]\nstem_diameter = stem[:stem_diameter]\n# Phytomer / Scale 3\nphytomer = Node(stem, NodeMTG(\"/\", \"Phytomer\", 1, 3))\n# Internode & Leaf / Scale 4\ninternode = Node(phytomer, NodeMTG(\"/\", \"Internode\", 1, 4))\nleaf = Node(internode, NodeMTG(\"+\", \"Leaf\", 1, 4))\ncompute_properties_leaf!(leaf, 1, nb_internodes, nb_leaves_alive, parameters, rng)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_properties_petiole!-NTuple{12, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_properties_petiole!","text":"compute_properties_petiole!(\n    petiole_node,\n    insertion_angle, rachis_length, zenithal_cpoint_angle,\n    width_base, height_base, cpoint_width_intercept,\n    cpoint_width_slope, cpoint_height_width_ratio,\n    petiole_rachis_ratio_mean,\n    petiole_rachis_ratio_sd, nb_sections;\n    rng=Random.MersenneTwister(1)\n)\n\nCompute the dimensional properties of a petiole.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\ninsertion_angle: the angle of insertion of the petiole on the stem (°)\nrachis_length: the length of the rachis (m)\nzenithal_cpoint_angle: the zenithal angle of the C point of the petiole, i.e. the tip (°)\nwidth_base: the width of the petiole at its base (m)\nheight_base: the height of the petiole at its base (m)\ncpoint_width_intercept: the intercept of the linear function for the width at the C point (m)\ncpoint_width_slope: the slope of the linear function for the width at the C point\ncpoint_height_width_ratio: the ratio of the height to width at the C point\npetiole_rachis_ratio_mean: the mean ratio of the petiole to rachis length\npetiole_rachis_ratio_sd: the standard deviation of the ratio of the petiole to rachis length\nnb_sections: the number of sections discretizing the petiole\nrng=Random.MersenneTwister(1): the random number generator\n\nReturns\n\nThe petiole node updated with properties.\n\nDetails\n\nProperties are computed based on the allometries of the petiole and the rachis:\n\nlength: the length of the petiole (m)\nazimuthal_angle: the azimuthal angle of the petiole (°)\nwidth_base: the width of the petiole at its base (m)\nheight_base: the height of the petiole at its base (m)\nwidth_cpoint: the width of the petiole at the C point (m)\nheight_cpoint: the height of the petiole at the C point (m)\nzenithalinsertionangle: the zenithal angle of insertion of the petiole on the stem (°)\nzenithalcpointangle: the zenithal angle of the C point of the petiole (°)\nsection_length: the length of the petiole sections (m)\nsectioninsertionangle: the zenithal angle of insertion between the petioles sections (°)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_properties_petiole_section!-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_properties_petiole_section!","text":"compute_properties_petiole_section!(petiole_node, section_node, index, nb_sections)\n\nCompute the dimension of a petiole section based on the dimensions of the petiole.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\nsection_node: the MTG Node of the section to be computed\nindex: the index of the section on the petiole, from 1 at the base to nb_sections.\nnb_sections: the number of sections discretizing the petiole\nsection_insertion_angle: the zenithal angle of the petioles sections (global angle, °)\n\nReturns\n\nThe section node updated with dimensional properties.\n\nDetails\n\nThe petiole_node should have the following attributes:\n\nwidth_base: the width of the petiole at its base (m)\nheight_base: the height of the petiole at its base (m)\nwidth_cpoint: the width of the petiole at the C point (m)\nheight_cpoint: the height of the petiole at the C point (m)\nsection_length: the length of the petiole sections (m)\ninsertion_angle: the angle of insertion of the petiole on the stem (°)\nsection_insertion_angle: the zenithal angle of insertion between the petioles sections (°)\nazimuthal_angle: the azimuthal angle at the insertion (°)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.compute_properties_stem!-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.compute_properties_stem!","text":"compute_properties_stem!(node, parameters, length_reference_leaf; rng=MersenneTwister(1234))\n\nCompute the properties of the stem node.\n\nArguments\n\nnode: the stem node\nparameters: the parameters of the Vpalm model\nlength_reference_leaf: the length of the reference leaf (usually, rank 17)\nrng=MersenneTwister(1234): the random number generator\n\nReturns\n\nThe stem node updated with properties.\n\nDetails\n\nThe stem dimensions are computed based on the parameters of the model:\n\nstembending: the bending of the stem. Uses the `VPalm.stembending` function.\nstemheight: the height of the stem. Uses the `VPalm.stemheight` function.\nstemdiameter: the diameter of the stem. Uses the `VPalm.stemdiameter` function.\n\nExamples\n\nusing XPalm.VPalm\nusing Unitful\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"references\", \"vpalm-parameter_file.yml\")\nparameters = read_parameters(file)\nnb_internodes = parameters[\"nb_leaves_emitted\"] + parameters[\"nb_internodes_before_planting\"] # The number of internodes emitted since the seed\nnb_leaves_alive = floor(Int, mean_and_sd(parameters[\"nb_leaves_mean\"], parameters[\"nb_leaves_sd\"], rng))\nnb_leaves_alive = min(nb_leaves_alive, nb_internodes)\n# Plant / Scale 1\nplant = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\n# Stem (& Roots) / Scale 2\nstem = Node(plant, NodeMTG(\"+\", \"Stem\", 1, 2))\ncompute_properties_stem!(stem, parameters, 3.0u\"m\"; rng=rng)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.create_leaflet_segments!-NTuple{8, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.create_leaflet_segments!","text":"create_leaflet_segments!(\n    unique_mtg_id,\n    leaflet_node,\n    scale,\n    leaflet_length,\n    width_max,\n    stiffness,\n    tapering,\n    leaflet_relative_pos;\n    xm_intercept, xm_slope,\n    ym_intercept, ym_slope  \n)\n\nCreate the segments that make up a leaflet with proper shape and bending properties.\n\nArguments\n\nunique_mtg_id: Reference to the unique ID counter\nleaflet_node: Parent leaflet node\nscale: MTG scale for the segments\nleaflet_length: Total length of the leaflet in meters\nwidth_max: Maximum width of the leaflet in meters\nstiffness: Stiffness value (Young's modulus) for biomechanical bending\ntapering: Tapering factor (how width decreases along length)\nleaflet_relative_pos: Relative position of the leaflet on the rachis (0-1)\nxm_intercept, xm_slope: Parameters for defining maximum leaflet width position\nym_intercept, ym_slope: Parameters for defining maximum leaflet width value\n\nReturns\n\nNothing (segments are added directly to the leaflet node as children)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.create_leaflets_for_side!-NTuple{12, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.create_leaflets_for_side!","text":"create_leaflets_for_side!(\n    unique_mtg_id,\n    rachis_node,\n    scale,\n    leaf_rank,\n    rachis_length,\n    nb_rachis_sections,\n    leaflets_position,\n    leaflets,\n    leaflet_max_length,\n    leaflet_max_width,\n    side,\n    parameters;\n    last_rank_unfolding=2,\n    rng=Random.MersenneTwister(1234)\n)\n\nCreate leaflets for one side of the palm frond rachis.\n\nArguments\n\nunique_mtg_id: Reference to the unique ID counter for MTG nodes\nrachis_node: Root node of the rachis\nscale: MTG scale for leaflets\nleaf_rank: Rank of the leaf (affects unfolding for young fronds)\nrachis_length: Total length of the rachis in meters\nnb_rachis_sections: Number of segments dividing the rachis\nleaflets_position: Array of positions along the rachis for each leaflet\nleaflets: NamedTuple with leaflet grouping information (group, group_size, plane)\nleaflet_max_length: Maximum length of leaflets (length of the longest leaflet)\nleaflet_max_width: Maximum width of leaflets (width of the widest leaflet)\nside: Side of rachis (1=right, -1=left)\nparameters: Model parameters\nlast_rank_unfolding=2: Rank at which leaflets are fully unfolded (default is 2)\nrng=Random.MersenneTwister(1234): Random number generator\n\nReturns\n\nNothing (leaflets are attached directly to the rachis node in the MTG structure)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.create_section-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.create_section","text":"create_section(section, section_type)\n\nFill in the matrix according to the section shape.\n\nArguments\n\nsection: Section matrix.\nsection_type: Section type (1: triangle bottom, 2: rectangle, 3: triangle top, 4: ellipse, 5: circle).\n\nReturns\n\nThe filled section matrix with 1s for cells inside the shape and 0s outside.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.create_single_leaflet-NTuple{11, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.create_single_leaflet","text":"create_single_leaflet(\n    unique_mtg_id,\n    index,\n    scale,\n    leaf_rank,\n    leaflet_relative_pos,\n    norm_leaflet_rank,\n    plane,\n    side,\n    leaflet_max_length,\n    leaflet_max_width,\n    parameters;\n    offset=0.0,\n    last_rank_unfolding=2,\n    rng=Random.MersenneTwister(1234)\n)\n\nCreate a single leaflet with properly computed angles, dimensions and segments.\n\nArguments\n\nunique_mtg_id: Reference to the unique ID counter\nindex: Index for the leaflet node (for identification in MTG)\nscale: MTG scale level for the leaflet\nleaf_rank: Rank of the leaf (affects unfolding for young leaves)\nleaflet_relative_pos: Relative position of leaflet on rachis (0 to 1)\nnorm_leaflet_rank: Normalized rank of the leaflet (0 to 1)\nplane: Plane type of leaflet (1=high/upward, 0=medium/horizontal, -1=low/downward)\nside: Side of the leaf (1=right, -1=left)\nleaflet_max_length: Maximum leaflet length in meters (length of the longest leaflet)\nleaflet_max_width: Maximum leaflet width in meters (width of the widest leaflet)\nparameters: Model parameters dictionary\noffset: Offset from the start of parent node (when applicable)\nlast_rank_unfolding: Rank at which leaflets are fully unfolded (default is 2)\nrng: Random number generator\n\nReturns\n\nThe created leaflet node with all its segment children\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.cylinder-Tuple{}","page":"XPalm.VPalm API","title":"XPalm.VPalm.cylinder","text":"cylinder()\ncylinder(r, l)\n\nReturns a normalized cylinder mesh, or a cylinder with radius r and length l.\n\nArguments\n\nr: The radius of the cylinder.\nl: The length of the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.default_parameters-Tuple{}","page":"XPalm.VPalm API","title":"XPalm.VPalm.default_parameters","text":"default_parameters(; type=\"static\")\n\nReturns a dictionary of default parameters for the VPalm model.\n\nArguments\n\ntype: The type of parameters to return, either \"static\" or \"dynamic\". Default is \"static\".\n\nDetails\n\nVPalm can be used in two modes:\n\n\"static\": For static plant architecture, where the plant structure does not change over time. The parameters are measured from one or several real oil palm plants and are used to build mockups of the plant architecture,\n\nwhich can then be used for simulations or visualizations around this age.\n\n\"dynamic\": For dynamic plant architecture, where the plant structure can change over time (e.g., growth, environmental effects). This is typically used for simulations that involve plant growth over time (like XPalm), or for digital twins of oil palm plants.\n\nExample\n\ndefault_params = default_parameters()\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.dist_and_angles_to_xyz-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.dist_and_angles_to_xyz","text":"dist_and_angles_to_xyz(dist_p2p1, vangle_xy, vangle_xz)\n\nTransform distances and angles into point coordinates.\n\nArguments\n\ndist_p2p1: Vector of segment lengths (m).\nvangle_xy: Vector of angles between the segment and the XY plane (radians).\nvangle_xz: Vector of angles between the segment and the XZ plane (radians).\n\nReturns\n\nThe points as a vector of Meshes.Point.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.draw_group_size-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Random.AbstractRNG","page":"XPalm.VPalm API","title":"XPalm.VPalm.draw_group_size","text":"draw_group_size(group, leaflet_type_frequencies, rng)\n\nDetermine the size of a leaflet group based on the relative position along the rachis and frequency patterns.\n\nArguments\n\ngroup: Index of the leaflet group based on its relative position on the rachis (1 to length(leaflet_type_frequencies)).\nleaflet_type_frequencies: Vector of NamedTuples representing frequency distributions for each rachis segment, with fields:\nhigh: Frequency of plane=+1 leaflets (first leaflet in each group), i.e. leaflets on \"high\" position\nmedium: Frequency of plane=0 leaflets (intermediate leaflets in groups), i.e. leaflets on \"medium\" position, horizontally inserted on the rachis\nlow: Frequency of plane=-1 leaflets (terminal leaflets in groups), i.e. leaflets on \"low\" position\nrng: Random number generator for stochastic determination, or nothing for deterministic behavior.\n\nDetails\n\nThis function implements an inverse relationship between the frequency of high (plane=1) leaflets and group size, modeling a fundamental biological pattern in palm frond architecture:\n\nSegments with high frequency of high leaflets produce many small groups of leaflets\nSegments with low frequency of high leaflets produce fewer, larger groups of leaflets\n\nWhen rng is provided, the calculation uses a probabilistic rounding mechanism to ensure proper  statistical distribution of group sizes. When rng is nothing, it uses deterministic rounding to the nearest integer. This creates the natural variation in leaflet grouping patterns seen along  real palm fronds, where clustering patterns change systematically from base to tip.\n\nReturns\n\nAn integer representing the number of leaflets in the group.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.draw_plane-Tuple{Any, Nothing}","page":"XPalm.VPalm API","title":"XPalm.VPalm.draw_plane","text":"draw_plane(frequencies, rng::Nothing)\n\nDraw the plane position for a leaflet based on its frequencies.\n\nArguments\n\nfrequencies: A NamedTuple with fields high, medium, and low representing the frequency of each leaflet type in the current rachis segment.\nrng: A random number generator (optional, can be Nothing for deterministic behavior\n\nReturns\n\nThe plane position for the leaflet, which can be:\n1 for high position (upward)\n0 for medium position (horizontal)\n-1 for low position (downward)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.elliptical_cylinder-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.elliptical_cylinder","text":"elliptical_cylinder(r1, r2, l)\n\nCreate an elliptical cylinder mesh.\n\nArguments\n\nr1: The radius of the cylinder in the x direction.\nr2: The radius of the cylinder in the y direction.\nl: The length of the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.exponetial-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.exponetial","text":"exponetial(x, a, b)\n\nCompute an exponential function at given x value.\n\nArguments\n\nx: The input value.\na: The coefficient a of the exponential function.\nb: The coefficient b of the exponential function.\n\nNote\n\nThe exponential function is defined as a * exp(b * x).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.final_angle-NTuple{4, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.final_angle","text":"final_angle(young_modulus, z_angle, length, tapering)\n\nCalculate the maximal deformation angle of a beam.\n\nArguments\n\nyoung_modulus: Value of Young's modulus\nz_angle: Angle from vertical (upright) in radians\nlength: Length of the beam where the load is applied\ntapering: Tapering factor of the beam\n\nReturns\n\nThe final angle from vertical at the cantilever extremity (in radians)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.group_leaflets-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.group_leaflets","text":"group_leaflets(leaflets_relative_position, leaflets_type_frequency, rng)\n\nCompute the group, group size and plane positions of each leaflet along the rachis.\n\nArguments\n\nleaflets_relative_position: Array of relative positions for the leaflets along the rachis (see relative_leaflet_position()).\nleaflets_type_frequency: Vector of NamedTuples representing frequency distributions along the rachis (if e.g. 10 values are provided, it means the rachis is divided into 10 sub-sections), with fields:\nhigh: Frequency of plane=+1 leaflets (first leaflet in each group), i.e. leaflets on \"high\" position\nmedium: Frequency of plane=0 leaflets (intermediate leaflets in groups), i.e. leaflets on \"medium\" position, horizontally inserted on the rachis\nlow: Frequency of plane=-1 leaflets (terminal leaflets in groups), i.e. leaflets on \"low\" position\nrng: Random number generator.\n\nDetails\n\nThis function:\n\n1. Organizes leaflets into groups based on position-dependent size distributions\n2. Assigns a spatial plane to each leaflet within a group:\n    - The first leaflet in each group is always placed on the high position (plane=1)\n    - Subsequent leaflets are positioned on medium (plane=0) or low (plane=-1) positions based on their frequency distribution at that rachis segment\n\nBiological Context\n\nGrouping of leaflets is a key morphological feature in palm species, particularly in oil palm (Elaeis guineensis). Unlike some palms with regularly spaced leaflets, oil palms exhibit distinctive clustering patterns where:\n\nLeaflets occur in groups of variable sizes, but typically around 3 leaflets per group\nWithin each group, leaflets emerge at different angles:\nThe first leaflet points upward (high position)\nOthers point horizontally or downward (medium and low positions)\nThe pattern of grouping changes along the rachis:\nCloser to the base: typically larger groups with more leaflets\nToward the tip: smaller groups or single leaflets\n\nThe model uses an inverse relationship between high-position leaflet frequency and group size to recreate the natural variation in leaflet insertion angle - sections with many high-position leaflets have smaller groups (but more of them), while sections with few high-position leaflets form larger groups.\n\nThe grouping pattern changes along the rachis, creating the characteristic appearance of palm fronds with varying leaflet arrangement  patterns from base to tip.\n\nReturns\n\nA NamedTuple containing arrays for:\n\ngroup: Group identifier for each leaflet\ngroup_size: Size of the group that each leaflet belongs to\nplane: Spatial position/orientation of each leaflet (1=high, 0=medium, -1=low)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.height_to_width_ratio-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.height_to_width_ratio","text":"height_to_width_ratio(x, ratio_point_c, ratio_point_a, pos_ratio_max, ratio_max)\n\nComputes the relative width along the rachis.\n\nArguments\n\nx: relative position on the rachis\nratio_point_c: ratio at point C\nratio_point_a: ratio at point A\npos_ratio_max: relative position of the maximum value of the ratio\nratio_max: maximum ratio value\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.inertia_flex_rota","page":"XPalm.VPalm API","title":"XPalm.VPalm.inertia_flex_rota","text":"inertia_flex_rota(base_width, height, orientation_angle, section_type, grid_size = 100)\n\nCompute the inertia of bending and torsion, and the cross-section area.\n\nArguments\n\nbase_width: Dimension of the base.\nheight: Dimension of the height.\norientation_angle: Section orientation angle (torsion, in radians).\nsection_type: Section type (see details).\ngrid_size: Number of discretizations (default to 100).\n\nDetails\n\nFor the section type, possible values are:\n\nsection_type = 1: triangle (bottom-oriented)\nsection_type = 2: rectangle\nsection_type = 3: triangle (top-oriented)\nsection_type = 4: ellipse\nsection_type = 5: circle\n\nReturns\n\nA NamedTuple with fields:\nig_flex: Bending inertia.\nig_tor: Torsion inertia.\nsr: Cross-section surface.\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.init_attributes_seed!-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.init_attributes_seed!","text":"init_attributes_seed!(plant, parameters; rng=Random.MersenneTwister(parameters[\"seed\"]))\n\nInitialize the attributes of a palm plant seed (one internode with one leaf), based on the provided parameters.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.internode_diameter-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.internode_diameter","text":"internode_diameter(internode_index, rank, stem_diameter, stem_base_shrinkage, stem_top_shrinkage)\n\nComputes the diameter of an internode at a given rank.\n\nArguments\n\ninternode_index: The index of the internode.\nrank: The rank of the internode.\nstem_diameter: The diameter of the stem at the base.\nstem_base_shrinkage: The shrinkage coefficient at the stem base.\nstem_top_shrinkage: The shrinkage coefficient at the stem top.\n\nReturns\n\nThe diameter of the internode (m).\n\nDetails\n\nA shrinking function is applied to the stem base and top to compute the diameter of the internode.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.internode_length-NTuple{6, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.internode_length","text":"Internode length model\n\nComputes the length of an internode at a given rank.\n\nArguments\n\ni/ internode_index: The index of the internode.\nNbl / nb_internodes: The total number of internodes == number of leaves emitted since planting.\nsh / stem_height: The height of the stem.\nR / internode_rank_no_expansion: The rank of the internode that will not expand.\nN / nb_internodes_before_planting: The number of internodes before planting.\nl_0 / internode_min_height: The minimal length of the internode.\n\nReturns\n\nThe length of the internode (m).\n\nDetails\n\nThe internode length is computed using a quadratic function. The objective is to have a internodes that are short and growing for the first emitted leaves (before nb_internodes_before_planting), and then getting to a stable \"constant\" height, and at the end for the youngest leaves, having nodes currently growing (smaller).\n\nThe internode length is computed as follows :   Internode length     ^ l   |      _____________________     |    /|                     ||   / |                     | l0 |  /  |                     |  |-|–-|––––––––––-|–-|––> Internode number       1   N                   N +   N + Nbl        \t\t\t\t\t\t  Nbl -                               R where :     - l0 is internode_min_height (m), the minimum height of the internode.     - l is internode_heigth_final (m), the maximum height of the internode.- N isnbinternodesbeforeplanting, the number of internodes before planting.     - R isinternoderanknoexpansion, the number of internodes not in expansion.     - Nbl is the number of leaves emitted since planting. with the conditions that :     - the sum of the areas of the first triangle, the rectangle and the last triangle is equal tostemheight.     - if the equation of the first line isa * x + b:         -a = (l - l0) / (N - 1)-b = l0 - a- the area of the first triangle isa * N * (N + 1) / 2 + b * Nand after development :l * N/2 + l0 * N/2- the area of the rectangle (between N + 1 and N + Nbl - R - 1) is(Nbl - R - 1) * l- if the equation of the last line isc * x + d, then:         -c = (l0 - l) / R-d = l0 - c * (Nbl + N)- the area of the last triangle is(R + 1) * (c * (2N + 2Nbl - R) / 2 + d)and after development :l * ((R + 1)/ 2) + l_0 * (-(R + 1) / 2 + R + 1)reminder:     - the sum of integers from m to n isn * (n + 1) / 2 - m * (m - 1) / 2- the sum of cx + d from m to n isc * (n * (n + 1) / 2 - m * (m - 1) / 2) + d * (n - m + 1)or(n - m + 1) * (c * (n + m) / 2 + d)`\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.interp_points-Union{Tuple{P}, Tuple{AbstractVector{P}, Any}} where P<:Meshes.Point","page":"XPalm.VPalm API","title":"XPalm.VPalm.interp_points","text":"interp_points(points, step)\n\nInterpolate points along a path to have equidistant points.\n\nArguments\n\npoints: Vector of Meshes.Point objects defining the original path.\nstep: Distance between interpolated points.\n\nReturns\n\nvec_points: Vector of interpolated Meshes.Point objects.\ni_discret_pts_exp: Indices of the original points in the interpolated path.\nvec_dist_p2p1: Vector of distances between consecutive points.\nvec_angle_xy: Vector of angles between segments and the XY plane.\nvec_angle_xz: Vector of angles between segments and the XZ plane.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaf_insertion_angle","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaf_insertion_angle","text":"leaf_insertion_angle(rank, leaf_max_angle=90, leaf_slope_angle=0.05, leaf_inflection_angle=40)\n\nCompute the insertion angle of the leaf on the internode.\n\nNote: The insertion angle is computed using a logistic function.\n\nArguments\n\nrank: The rank of the leaf.\nleaf_max_angle: The maximum angle of the leaf.\nleaf_slope_angle: The slope of the logistic function.\nleaf_inflection_angle: The inflection point of the logistic function.\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_azimuthal_angle-NTuple{7, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_azimuthal_angle","text":"leaflet_azimuthal_angle(relative_pos, side, angle_c, angle_slope, angle_a, angle_sdp, rng)\n\nCalculate the leaflet insertion angle in the horizontal plane (in degrees).\n\nArguments\n\nrelative_pos: Relative position of the leaflet on the rachis [0 to 1].\nside: Side of the leaf (1 for right, -1 for left).\nangle_c: Constant parameter for the axial angle calculation (°).\nangle_slope: Slope parameter for the axial angle calculation (°).\nangle_a: Amplitude parameter for the axial angle calculation (°).\nangle_sdp: Standard deviation percentage for random variation (°).\nrng: Random number generator.\n\nReturns\n\nHorizontal insertion angle in degrees.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_length_at_bpoint-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_length_at_bpoint","text":"leaflet_length_at_bpoint(rachis_length, intercept, slope)\n\nCompute the length of leaflets at the B point of the rachis using a linear relationship.\n\nArguments\n\nrachis_length: The total length of the rachis (m).\nintercept: The intercept parameter of the linear function (m).\nslope: The slope parameter of the linear function (dimensionless).\n\nDetails\n\nThis function uses a linear model to determine leaflet length at the B point:\n\nleaflet_length = intercept + slope * rachis_length\n\nThe B point is a key reference point on the rachis that marks the transition from an oval to a round shape of the  rachis. The leaflet length at this point serves as a reference for calculating the distribution of leaflet lengths  along the entire rachis.\n\nReturns\n\nThe length of leaflets at the B point position (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_length_max-NTuple{7, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_length_max","text":"leaflet_length_max(\n    leaflet_length_at_b, \n    relative_position_bpoint, \n    relative_length_first_leaflet, \n    relative_length_last_leaflet, \n    relative_position_leaflet_max_length, \n    relative_position_bpoint_sd, \n    rng\n)\n\nCalculate the maximum leaflet length for the rachis, used to scale the relative length profile.\n\nArguments\n\nleaflet_length_at_b: Length of leaflets at the B point on the rachis (m).\nrelative_position_bpoint: Relative position of the B point along the rachis (0 to 1).\nrelative_length_first_leaflet: Relative length of the first leaflet at rachis base [0 to 1].\nrelative_length_last_leaflet: Relative length of the last leaflet at rachis tip [0 to 1].\nrelative_position_leaflet_max_length: Relative position where leaflets reach maximum length [0 to 1].\nrelative_position_bpoint_sd: Standard deviation for stochastic variation in B point position.\nrng: Random number generator.\n\nDetails\n\nThis function calculates the maximum leaflet length that would result in the specified  leaflet length at the B point, considering the shape of the length profile along the rachis.\n\nThe calculation uses the inverse of the relative length function at the B point position  to determine what maximum value would yield the desired length at that specific position.\n\nBiological Context\n\nIn palm fronds, leaflet length typically follows a bell-shaped distribution along the rachis:\n\nLeaflets are short at the base (petiole end)\nThey increase in length to reach a maximum somewhere close to the middle of the rachis\nThey decrease in length toward the tip\n\nThe B point is a key morphological reference point where the rachis cross-section  transitions from oval to round. By knowing the leaflet length at this specific point, we can calculate the maximum leaflet length for the entire frond, which serves as a scaling factor for all other leaflets.\n\nThe stochastic variation in B point position reflects natural biological variability between individual palms or fronds.\n\nReturns\n\nThe maximum leaflet length for the rachis (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_width_at_bpoint-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_width_at_bpoint","text":"leaflet_width_at_bpoint(rachis_length, intercept, slope)\n\nCalculate leaflet width at B point (reference point).\n\nArguments\n\nrachis_length: The total length of the rachis (m).\nintercept: The intercept parameter of the linear function (m).\nslope: The slope parameter of the linear function (dimensionless).\n\nDetails\n\nThis function uses a linear model to determine leaflet width at the B point:\n\nleaflet_width = intercept + slope * rachis_length\n\nThe B point is a key reference point on the rachis that marks the transition  between different architectural zones. The leaflet width at this point serves  as a reference for calculating the distribution of leaflet widths along the  entire rachis.\n\nReturns\n\nThe width of leaflets at the B point position (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_width_max-NTuple{7, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_width_max","text":"leaflet_width_max(\n    leaflet_width_at_b,\n    relative_position_bpoint,\n    width_first,\n    width_last,\n    pos_width_max,\n    relative_position_bpoint_sd,\n    rng\n)\n\nleaflet_width_max(\n    leaflet_width_at_b,\n    relative_position_bpoint,\n    width_first,\n    width_last,\n    pos_width_max,\n)\n\nCalculate the maximum leaflet width for the rachis, used to scale the width profile.\n\nArguments\n\nleaflet_width_at_b: Width of leaflets at the B point on the rachis (m).\nrelative_position_bpoint: Mean relative position of the B point along the rachis [0 to 1].\nwidth_first: Relative width of the first leaflet at rachis base [0 to 1].\nwidth_last: Relative width of the last leaflet at rachis tip [0 to 1].\npos_width_max: Relative position where leaflets reach maximum width [0 to 1].\nrelative_position_bpoint_sd: Standard deviation for stochastic variation in B point position (optional).\nrng: Random number generator (optional). \n\nDetails\n\nThis function calculates the maximum leaflet width that would result in the specified  width at the B point, considering the shape of the width profile along the rachis.\n\nThe calculation uses the inverse of the relative width function at the B point position  to determine what maximum value would yield the desired width at that specific position.\n\nBiological Context\n\nIn palm fronds, leaflet width typically varies along the rachis:\n\nNarrow leaflets at the base (petiole end)\nWider leaflets in the middle region\nNarrowing again toward the tip\n\nBy knowing the leaflet width at the B point, we can calculate the maximum  leaflet width for the entire frond, which serves as a scaling factor for  all other leaflets.\n\nReturns\n\nThe maximum leaflet width for the rachis (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_zenithal_angle-NTuple{12, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_zenithal_angle","text":"leaflet_zenithal_angle(relative_pos, leaflet_type, side, high_a0_sup, high_amax_sup, high_a0_inf, high_amax_inf, \n             low_a0_sup, low_amax_sup, low_a0_inf, low_amax_inf, rng)\n\nCalculate the leaflet insertion angle in the vertical plane (in degrees).\n\nArguments\n\nrelative_pos: Relative position of the leaflet on the rachis [0 to 1].\nleaflet_type: Type of leaflet (-1=down, 0=medium, 1=up).\nside: Side of the leaf (1 for right, -1 for left).\nhigh_a0_sup: Upper bound of angle at position 0 for high position leaflets.\nhigh_amax_sup: Upper bound of maximum angle for high position leaflets.\nhigh_a0_inf: Lower bound of angle at position 0 for high position leaflets.\nhigh_amax_inf: Lower bound of maximum angle for high position leaflets.\nlow_a0_sup: Upper bound of angle at position 0 for low position leaflets.\nlow_amax_sup: Upper bound of maximum angle for low position leaflets.\nlow_a0_inf: Lower bound of angle at position 0 for low position leaflets.\nlow_amax_inf: Lower bound of maximum angle for low position leaflets.\nrng: Random number generator.\n\nReturns\n\nVertical insertion angle in degrees.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.leaflet_zenithal_angle_boundaries","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflet_zenithal_angle_boundaries","text":"leaflet_zenithal_angle_boundaries(rel_pos, a0, a_max, xm=0.5)\n\nCalculate the boundaries of the radial angle based on position along the rachis.\n\nArguments\n\nrel_pos: Relative position on the rachis [0 to 1].\na0: Radial angle around C point.\na_max: Maximum value of radial angle (in degrees).\nxm: Relative position on rachis of the maximum radial angle (default: 0.5).\n\nReturns\n\nRadial angle in degrees.\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.leaflets!-NTuple{6, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.leaflets!","text":"leaflets!(unique_mtg_id, rachis_node, scale, leaf_rank, rachis_length, parameters; rng=Random.MersenneTwister())\n\nCreate leaflets for a given rachis node, computing their positions, types, and dimensions.\n\nArguments\n\nunique_mtg_id: Reference to a unique identifier for the MTG nodes.\nrachis_node: The parent node of the rachis where leaflets will be attached.\nscale: The scale of the leaflets in the MTG.\nleaf_rank: The rank of the leaf associated with the rachis.\nrachis_length: The total length of the rachis in meters.\nheight_cpoint: The height of the central point of the rachis in meters.\nwidth_cpoint: The width of the central point of the rachis in meters.\nzenithal_cpoint_angle: The zenithal angle of the central point of the rachis in degrees.\nparameters: A dictionary containing biomechanical parameters for the leaflets.\nrng: A random number generator for stochastic processes (default is a new MersenneTwister).\n\nNote\n\nThe parameters is a Dict{String} containing the following keys:\n\n\"leaflets_nb_max\": Maximum number of leaflets per rachis.\n\"leaflets_nb_min\": Minimum number of leaflets per rachis.\n\"leaflets_nb_slope\": Slope for the number of leaflets distribution.\n\"leaflets_nb_inflexion\": Inflexion point for the number of leaflets distribution.\n\"nbLeaflets_SDP\": Standard deviation for the number of leaflets.\n\"leaflet_position_shape_coefficient\": Shape coefficient for the relative positions of leaflets.\n\"leaflet_frequency_high\": Frequency of high-position leaflets.\n\"leaflet_frequency_low\": Frequency of low-position leaflets.\n\"leaflet_frequency_shape_coefficient\": Shape coefficient for the frequency distribution of leaflets.\n\"leaflet_between_to_within_group_ratio\": Ratio of spacing between groups to within groups.\n\"leaflet_length_at_b_intercept\": Intercept for the length of leaflets at point B.\n\"leaflet_length_at_b_slope\": Slope for the length of leaflets at point B.\n\"relative_position_bpoint\": Relative position of point B along the rachis.\n\"relative_position_bpoint_sd\": Standard deviation of the relative position of point B.\n\"relative_length_first_leaflet\": Relative length of the first leaflet.\n\"relative_length_last_leaflet\": Relative length of the last leaflet.\n\"relative_position_leaflet_max_length\": Relative position of the leaflet with maximum length.\n\"leaflet_width_at_b_intercept\": Intercept for the width of leaflets at point B.\n\"leaflet_width_at_b_slope\": Slope for the width of leaflets at point B.\n\"relative_width_first_leaflet\": Relative width of the first leaflet.\n\"relative_width_last_leaflet\": Relative width of the last leaflet.\n\"relative_position_leaflet_max_width\": Relative position of the leaflet with maximum width.\n\"rachis_nb_segments\": Number of segments in the rachis.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.linear-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.linear","text":"linear(x, intercept, slope)\n\nCompute a linear function at given x value.\n\nArguments\n\nx: The input value.\nintercept: The intercept of the linear function.\nslope: The slope of the linear function.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.local_flexion-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.local_flexion","text":"local_flexion(current_angle, final_angle, young_modulus, tapering, relative_position)\n\nCalculate the local bending angle at a specific position along the beam.\n\nArguments\n\ncurrent_angle: Current angle in radians\nfinal_angle: Final angle of the beam in radians\nyoung_modulus: Value of Young's modulus\ntapering: Tapering factor of the beam\nrelative_position: Relative position along the beam (0 to 1)\n\nReturns\n\nFlexion angle at the current position (in radians)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.logistic-NTuple{4, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.logistic","text":"logistic(x, max, slope, inflection)\n\nCompute a logistic function.\n\nArguments\n\nx: The input value.\nmax: The maximum value of the logistic function.\nslope: The slope of the logistic function.\ninflection: The inflection point of the logistic function.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.mean_and_sd-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Random.AbstractRNG","page":"XPalm.VPalm API","title":"XPalm.VPalm.mean_and_sd","text":"mean_and_sd(mean, sd, rng)\n\nCompute a random value from a normal distribution with a given mean and standard deviation.\n\nArguments\n\nmean: The mean of the normal distribution.\nsd: The standard deviation of the normal distribution.\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.mtg_skeleton-Tuple{Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.mtg_skeleton","text":"mtg_skeleton(parameters; rng=Random.MersenneTwister(parameters[\"seed\"]))\n\nMakes an MTG skeleton with nb_leaves_emitted leaves, including all intermediate organs:\n\nPlant: the whole palm\nStem: the stem of the plant, i.e. the remaining part of the plant after the leaves have been removed\nPhytomer: the part that includes the leaf and the internode\nInternodes: the part of the phytomer that is between two leaves\nLeaf: the leaf of the plant, also called frond\n\nNote: this skeleton does not include reproductive organs (inflorescences, fruits) or the scales that decompose the leaf (petiole, rachis, leaflets).\n\nArguments\n\nparameters: The parameters for the MTG skeleton. See VPalm.default_parameters() for the default parameters.\nrng: (optional) The random number generator to use for stochastic processes. Defaults to Random.MersenneTwister(parameters[\"seed\"]), but can be set to nothing to disable randomness (for testing).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"files\", \"parameter_file.yml\")\nparameters = read_parameters(file)\nmtg_skeleton(parameters)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.normal_deviation_draw-Union{Tuple{T}, Tuple{Any, T}} where T<:Random.AbstractRNG","page":"XPalm.VPalm API","title":"XPalm.VPalm.normal_deviation_draw","text":"normal_deviation_draw(sd, rng)\n\nDraw a random value from a normal distribution with a given standard deviation.\n\nArguments\n\nsd: The standard deviation of the normal distribution.\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.normal_deviation_percent_draw-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.normal_deviation_percent_draw","text":"normal_deviation_percent_draw(value, sdp, rng)\n\nCalculate a normally distributed random deviation based on a percentage of the value.\n\nArguments\n\nvalue: Base value.\nsd: Standard deviation in %.\nrng: Random number generator.\n\nReturns\n\nThe random deviation.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.normalize_positions!-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.normalize_positions!","text":"normalize_positions!(positions, rachis_length)\n\nScale and offset positions to span the full rachis length.\n\nArguments\n\npositions: Vector of positions to be modified in place.\nrachis_length: Total length of rachis in meters.\n\nDetails\n\nThis function:\n\nOffsets positions so the first leaflet is at position 0\nScales all positions to ensure the last leaflet is exactly at rachis_length\nMaintains the relative spacing pattern established by previous processing\n\nThis ensures leaflets are properly distributed along the entire rachis while preserving the characteristic grouping patterns.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.petiole-NTuple{7, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole","text":"petiole(parent_node, index, scale, rachis_length, zenithal_insertion_angle, zenithal_cpoint_angle, parameters)\n\nMake a leaf petiole.\n\nArguments\n\nunique_mtg_id: a next free unique id for the MTG nodes\nparent_node: the parent node on which the petiole will be attached\nindex: the MTG index of the petiole\nscale: the MTG scale of the petiole\nrachis_length: the rachis length, used to feed allometries to compute the petiole dimensions\nzenithal_insertion_angle: petiole insertion angle\nzenithal_cpoint_angle: angle at the C point (tip of the petiole, starting point of the rachis)\nparameters: a list of parameters as a Dict{String}:\n\"leafbasewidth\": the base width of the petiole (m)\n\"leafbaseheight\": the base heigth of the petiole (m)\n\"cpointwidthintercept\": petiole width at the c-point intercept for linear interpolation (m)\n\"cpointwidthslope\": petiole width at the c-point slope for linear interpolation\n\"cpointheightwidth_ratio\": height to width ratio at the C point\n\"petiolerachisratio_mean\": the average value of the ratio between rachis length and petiole length\n\"petiolerachisratio_sd\": its standard deviation\n\"petiolenbsegments\": the number of segments used to discretize the petiole\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.petiole_azimuthal_angle-Tuple{}","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole_azimuthal_angle","text":"petiole_azimuthal_angle(; rng=Random.MersenneTwister(1))\n\nCompute the azimuthal angle of the petiole based on the petiole/rachis length ratio.\n\nArguments\n\npetiole_rachis_ratio_mean: Average value of the petiole/rachis length ratio\npetiole_rachis_ratio_sd: Standard deviation of the petiole/rachis length ratio\nrng: Random number generator\n\nReturns\n\nThe azimuthal angle of the petiole (°)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.petiole_dimensions_at_cpoint","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole_dimensions_at_cpoint","text":"petiole_dimensions_at_cpoint(rachis_length, cpoint_width_intercept, cpoint_width_slope, cpoint_height_width_ratio)\n\nCompute the width and height of the petiole at the C point (end-point).\n\nArguments\n\nrachis_length: Length of the rachis (m)\ncpoint_width_intercept=0.0098u\"m\": Intercept of the linear relationship between rachis width at C point and rachis length (m)\ncpoint_width_slope=0.012: Slope of the linear relationship\ncpoint_height_width_ratio=0.568: Ratio between the height and width of the leaf at C point\n\nReturns\n\nA named tuple with the following keys:\n\nwidth_cpoint: Width at the C point of the petiole (m)\nheight_cpoint: Height at the C point of the petiole (m)\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.petiole_height-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole_height","text":"petiole_height(relative_position, height_cpoint, height_base)\n\nCompute the height profile along the petiole (m).\n\nArguments\n\nrelative_position: Position along the petiole (0-1)\nheight_base: Height at the base of the leaf\nheight_cpoint: Height of the leaf section at C point\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.petiole_length","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole_length","text":"petiole_length(petiole_rachis_ratio_mean, petiole_rachis_ratio_sd, rachis_length; rng=Random.MersenneTwister(1))\n\nCompute the length of the petiole based on the rachis length and the petiole/rachis length ratio.\n\nArguments\n\nrachis_length: Length of the rachis (m)\npetiole_rachis_ratio_mean=0.25: Average value of the petiole/rachis length ratio\npetiole_rachis_ratio_sd=0.034: Standard deviation of the petiole/rachis length ratio\nrng: Random number generator\n\nReturns\n\nThe length of the petiole (m)\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.petiole_sections!-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole_sections!","text":"petiole_sections!(petiole_node, petiole_nb_segments, unique_mtg_id)\n\nCreate the sections of a petiole.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\npetiole_nb_segments: the number of segments used to discretize the petiole\nunique_mtg_id: a next free unique id for the MTG nodes, given as a Ref{Int}\n\nReturns\n\nNothing, the petiole node is updated in-place with its sections.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.petiole_width-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.petiole_width","text":"petiole_width(relative_position, width_cpoint, width_base)\n\nCompute the width profile along the petiole (m).\n\nArguments\n\nrelative_position: Position along the petiole (0-1) \nwidth_base: Width at base of leaf\nwidth_cpoint: Width of the leaf at C point\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.phyllotactic_angle-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.phyllotactic_angle","text":"phyllotactic_angle(phyllotactic_angle_mean, phyllotactic_angle_sd; rng)\n\nComputes the phyllotactic angle (°) using an average angle and a standard deviation (random draw from a normal distribution).\n\nArguments\n\nphyllotactic_angle_mean: The average phyllotactic angle (°).\nphyllotactic_angle_sd: The standard deviation of the phyllotactic angle (°).\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.piecewise_linear_area-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.piecewise_linear_area","text":"piecewise_linear_area(x, y)\n\nCalculate the area under a piecewise linear function. Equivalent to PiecewiseFunctionArea in the Java version.\n\nArguments\n\nx: Array of x-coordinates of the control points.\ny: Array of y-coordinates of the control points.\n\nReturns\n\nArea under the piecewise linear function.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.plane-Tuple{}","page":"XPalm.VPalm API","title":"XPalm.VPalm.plane","text":"create_plane_mesh()\n\nCreate a simple rectangular plane mesh that will be used as a reference for leaflet segments. The plane is created in the XZ plane with width along X and length along Z.\n\nReturns\n\nA Meshes.SimpleMesh object representing a simple rectangular plane mesh\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.properties_petiole_section-NTuple{9, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.properties_petiole_section","text":"properties_petiole_section(\n    index, nb_sections, width_base, height_base,\n    width_cpoint, height_cpoint, petiole_section_length,\n    petiole_insertion_angle, petiole_section_insertion_angle,\n    azimuthal_angle\n)\n\nCompute the properties of each section of the petiole.\n\nArguments\n\nindex: The index of the section within all sections (1-nb_sections)\nnb_sections: The number of sections discretizing the petiole\nwidth_base: Width of the petiole at its base (m)\nheigth_base: Height of the petiole at its base (m)\nwidth_cpoint: Width of the petiole at the C point (tip of the petiole, i.e. transition point to rachis, m)\nheight_cpoint: Height at the C point (m)\npetiole_section_length: The length of the petiole sections (m)\npetiole_insertion_angle: Zenithal angle of insertion between the petiole and the stipe (local angle, relative to the stipe, °)\npetiole_section_insertion_angle: The zenithal angle of insertion between the petioles sections (°)\nazimuthal_angle: Azimuthal angle at the insertion (°)\n\nReturns\n\nA vector of dimensions for each section, given as a named tuple:\n\nwidth: width of the section (m)\nheight: height of the section (m)\nlength: length of the section (m)\nzenithal_angle: zenithal angle of the section (global angle, °)\nazimuthal_angle: azimuthal angle of the section (global angle, °)\ntorsion_angle: torsion angle of the section (°)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.rachis-NTuple{10, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.rachis","text":"rachis(unique_mtg_id, index, scale, leaf_rank, rachis_length, height_cpoint, width_cpoint, zenithal_cpoint_angle, fresh_biomass, parameters; rng)\n\nBuilds a rachis node in the MTG structure.\n\nArguments\n\nunique_mtg_id: A reference to a unique identifier for the MTG nodes.\nindex: The index of the rachis segment.\nscale: The scale of the rachis segment.\nleaf_rank: The rank of the leaf associated with the rachis.\nrachis_length: The length of the rachis (m).\nheight_cpoint: The height of the central point of the rachis (m).\nwidth_cpoint: The width of the central point of the rachis (m).\nzenithal_cpoint_angle: The zenithal angle of the central point of the rachis (°).\nfresh_biomass: The fresh biomass of the rachis (kg).\nparameters: A dictionary containing biomechanical parameters for the rachis (see below).\nrng: A random number generator for stochastic processes.\n\nNote\n\nThe parameters is a Dict{String} containing the following keys:\n\n\"rachis_nb_segments\": The number of segments in the rachis.\n\"rachis_twist_initial_angle\": The initial twist angle of the rachis (°).\n\"rachis_twist_initial_angle_sdp\": The standard deviation of the initial twist angle (°).\n\"elastic_modulus\": The elastic modulus of the rachis material (Pa).\n\"shear_modulus\": The shear modulus of the rachis material (Pa).\n\"leaflet_length_at_b_intercept\": The intercept for the leaflet length at point B (m).\n\"leaflet_length_at_b_slope\": The slope for the leaflet length at point B (m).\n\"relative_position_bpoint\": The relative position of point B along the rachis (m).\n\"relative_position_bpoint_sd\": The standard deviation of the relative position of point B (m).\n\"relative_length_first_leaflet\": The relative length of the first leaflet (m).\n\"relative_length_last_leaflet\": The relative length of the last leaflet (m).\n\"relative_position_leaflet_max_length\": The relative position of the leaflet with maximum length (m).\n\"height_rachis_tappering\": The height at which the rachis tapers (m).\n\"rachis_width_tip\": The width of the rachis tip (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.rachis_expansion-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.rachis_expansion","text":"rachis_expansion(leaf_rank, rachis_final_length)\n\nSimple function to compute the rachis expansion (using an expansion factor)\n    based on the leaf rank.\n\n# Arguments\n\n- `leaf_rank`: The rank of the leaf.\n- `rachis_final_length`: The final length of the rachis.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.rachis_height-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.rachis_height","text":"rachis_height(relative_position, cpoint_height, rachis_height_tappering)\n\nComputes the rachis height (m) at a given relative position using a the height at C Point and rachis tappering.\n\nArguments\n\nrelative_position: The relative position along the rachis (0: base to 1: tip).\ncpoint_height: The height of the rachis at the C point, i.e. rachis base (m).\nrachis_height_tappering: The tappering factor for the rachis height.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.rachis_length_from_biomass-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.rachis_length_from_biomass","text":"rachis_length_from_biomass(rachis_biomass, leaf_length_intercept, leaf_length_slope)\n\nCompute the length of the rachis based on its biomass using a linear relationship.\n\nArguments\n\nrachis_biomass: The biomass of the rachis (g).\nleaf_length_intercept: The intercept of the linear relationship for leaf length.\nleaf_length_slope: The slope of the linear relationship for leaf length.\n\nReturns\n\nThe length of the rachis (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.rachis_width-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.rachis_width","text":"rachis_width(relative_position, cpoint_width, rachis_width_tip)\n\nComputes the rachis width (m) at a given relative position using the width at C Point and rachis width at the tip.\n\nArguments\n\nrelative_position: The relative position along the rachis (0: base to 1: tip).\ncpoint_width: The width of the rachis at the C point, i.e. rachis base (m).\nrachis_width_tip: The width of the rachis at the tip (m).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.read_parameters-Tuple{Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.read_parameters","text":"read_parameters(file; verbose=true)\n\nReads a parameter file and returns the contents as an ordered dictionary.\n\nArguments\n\nfile: The path to the parameter file.\nverbose: Whether to show warnings for units (default: true)\n\nReturns\n\nAn ordered dictionary containing the contents of the parameter file with appropriate units.\n\nExample\n\nfile = joinpath(dirname(dirname(pathof(VPalm))),\"test\",\"files\",\"parameter_file.yml\")\nread_parameters(file)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.read_ply-Tuple{Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.read_ply","text":"read_ply(fname)\n\nReads a PLY file and returns a Meshes.SimpleMesh object.\n\nArguments\n\nfname: The path to the PLY file.\n\nReturns\n\nA Meshes.SimpleMesh object.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.relative_leaflet_length-NTuple{4, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.relative_leaflet_length","text":"relative_leaflet_length(x, relative_length_first_leaflet, relative_length_last_leaflet, relative_position_leaflet_max_length)\n\nRelative leaflet length given by their relative position along the rachis.\n\nArguments\n\nx: relative leaflet position on the rachis (0: base to 1: tip)\nrelative_length_first_leaflet: relative length of the first leaflet on the rachis (0 to 1)\nrelative_length_last_leaflet: relative length of the last leaflet on the rachis  (0 to 1)\nrelative_position_leaflet_max_length: relative position of the longest leaflet on the rachis (0.111 to 0.999)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.relative_leaflet_position-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.relative_leaflet_position","text":"relative_leaflet_position(relative_rank, shape_coefficient)\n\nCompute the relative leaflet position on the rachis.\n\nArguments\n\nrelative_rank: Relative leaflet rank, usually in the form of (0 to 1].\nshape_coefficient: Shape coefficient (around 0).\n\nReturns\n\nThe relative leaflet position, in the same form as relative_rank, usually (0 to 1].\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.relative_leaflet_width-NTuple{4, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.relative_leaflet_width","text":"relative_leaflet_width(x, width_first, width_last, pos_width_max)\n\nCalculate the relative leaflet width at a given position along the rachis.\n\nArguments\n\nx: Relative position of the leaflet on the rachis [0 to 1].\nwidth_first: Relative width of the first leaflet (at rachis base).\nwidth_last: Relative width of the last leaflet (at rachis tip).\npos_width_max: Relative position where leaflets reach maximum width [0 to 1].\n\nDetails\n\nThis function uses a piecewise linear model to calculate relative leaflet width:\n\nFrom base to maximum width position: Linear increase from width_first to 1.0\nFrom maximum width position to tip: Linear decrease from 1.0 to width_last\n\nBiological Context\n\nThe width of leaflets along a palm frond typically follows a pattern where:\n\nLeaflets start relatively narrow at the base\nWiden to reach maximum width at some point along the rachis\nNarrow again toward the tip\n\nReturns\n\nThe relative width at position x [0 to 1].\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.shrink_leaflets_in_groups!","page":"XPalm.VPalm API","title":"XPalm.VPalm.shrink_leaflets_in_groups!","text":"shrink_leaflets_in_groups!(positions, leaflets, ratio=2.0)\n\nAdjust the spacing between leaflets to create appropriate within-group and between-group distances.\n\nArguments\n\npositions: Vector of current leaflet positions along the rachis.\nleaflets: A NamedTuple containing arrays for leaflet properties (group, group_size, plane).\nratio=2.0: Ratio of inter-group to intra-group spacing.\n\nDetails\n\nThis function implements a biological principle where leaflets within the same group are positioned closer together than leaflets in different groups. It:\n\nUses a fixed ratio (2:1) between inter-group and intra-group spacing\nPreserves the overall distribution pattern while creating distinct groups\nProcesses each group sequentially, adjusting positions based on group size\n\nBiological Context\n\nIn many palm species, particularly oil palm, leaflets appear in distinct groups along the rachis. This grouping pattern is characterized by:\n\nConsistent, smaller spacing between leaflets within the same group\nLarger spacing between adjacent groups\nThe ratio between these spacings is typically species-specific\n\nThis spacing pattern is essential for the palm's characteristic appearance and  affects light interception patterns along the frond.\n\n\n\n\n\n","category":"function"},{"location":"vpalm/api/#XPalm.VPalm.snag-Tuple{}","page":"XPalm.VPalm API","title":"XPalm.VPalm.snag","text":"snag()\nsnag(l, w, h)\n\nReturns a normalized snag mesh, or a snag mesh with given dimensions in m.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.stem_bending-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.stem_bending","text":"stem_bending(stem_bending_mean, stem_bending_sd; rng)\n\nComputes the stem bending (°) using an average bending and a standard deviation (random draw from a normal distribution).\n\nArguments\n\nstem_bending_mean: The average stem bending (°).\nstem_bending_sd: The standard deviation of the stem bending (°).\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.stem_diameter-NTuple{6, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.stem_diameter","text":"stem_diameter(rachis_length_reference, stem_diameter_max, stem_diameter_slope, stem_diameter_inflection, stem_diameter_residual; rng)\n\nComputes the stem diameter (m) at a given rachis length reference (m).\n\nArguments\n\nrachis_length_reference: The rachis length reference (m). Taken as the rachis length of the first leaf.\nstem_diameter_max: The maximum stem diameter (m).\nstem_diameter_slope: The slope of the logistic function.\nstem_diameter_inflection: The inflection point of the logistic function.\nstem_diameter_residual: The residual of the stem diameter (m).\nstem_diameter_snag: The diameter estimation due to snags (m).\nrng: The random number generator.\n\nDetails\n\nThe stem diameter is computed using a logistic function, and then some variability is added to simulate natural variations that might occur in real-world scenarios.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.stem_height-NTuple{6, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.stem_height","text":"stem_height(nb_leaves_emitted, initial_stem_height, stem_height_coefficient, internode_length_at_maturity, stem_growth_start; rng)\n\nComputes the stem height (m) at a given number of leaves emitted.\n\nArguments\n\nnb_leaves_emitted: The number of leaves emitted from planting.\ninitial_stem_height: The initial stem height at planting (m).\nstem_height_coefficient: The coefficient of the exponential function.\ninternode_length_at_maturity: The internode length when the plant is mature (m).\nstem_growth_start: The number of leaves emitted at which the stem starts to grow (m). This is because the stem does not grow at the same rate at the beginning of the plant's life,\n\nbecause it first grows more in diameter than in height.\n\nstem_height_variation: The variation of the stem height (m) due to the random draw from a normal distribution.\nrng: The random number generator.\n\nDetails\n\nThe stem height is computed using an exponential function for the first stem_growth_start leaves emitted, and then a linear function for the remaining leaves emitted.\n\nNote that the stem height can also be subject to some variability using stem_height_variation, simulating natural variations that might occur in real-world scenarios, but this variability will never make the stem height go below 30% of the intial computed height.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.unbend-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.unbend","text":"unbend(distance, inclination)\n\nRemoves torsion and bending of a bent beam by transforming it into a straight line, while preserving its insertion angle (inclination angle of the first segment).\n\nArguments\n\ndistance: Vector of distances between consecutive points (in meters)\ninclination: Vector of inclination angles (in degrees), only the first value is used\n\nReturns\n\nA vector of Meshes.Point objects representing the unbent positions\n\nDetails\n\nThis function creates a straight line with the same cumulative length as the input distances, while maintaining the insertion angle specified by the first inclination value. The output points represent the unbent state of a curved structure.\n\nNote\n\nMainly used to compute the input coordinates for bend() from experimental points.\n\nExample\n\nusing VPalm, Unitful, Meshes\ndistances = [0.001, 1.340, 1.340, 0.770, 0.770]u\"m\";\ninclinations = [48.8, 48.8, 48.8, 48.8, 48.8];  # degrees\npoints = VPalm.unbend(distances, inclinations)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.update_leaflet_angles!-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.update_leaflet_angles!","text":"update_leaflet_angles!(\n    leaflet, leaf_rank; \n    last_rank_unfolding=2, unique_mtg_id=new_id(leaflet), \n    xm_intercept=0.176, xm_slope=0.08, \n    ym_intercept=0.51, ym_slope=-0.025\n)\n\nUpdate the angles and stiffness of a leaflet based on its position, side, and leaf rank.\n\nArguments\n\nleaflet: The leaflet node to update\nleaf_rank: The rank of the leaf (affects unfolding for young leaves)\nlast_rank_unfolding: Rank at which leaflets are fully unfolded (default is 2)\nunique_mtg_id: Reference to the unique ID counter for MTG nodes (default is the maximum ID in the MTG)\nxm_intercept, xm_slope: Parameters for defining maximum leaflet width position\nym_intercept, ym_slope: Parameters for defining maximum leaflet width value\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.update_petiole_angles!-Tuple{Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.update_petiole_angles!","text":"update_petiole_angles!(petiole_node)\n\nUpdate the angles of the petiole segments based on the petiole node properties.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\n\nReturns\n\nNothing, the petiole node is updated in-place with its segments angles.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.update_rachis_angles!-NTuple{8, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.update_rachis_angles!","text":"update_rachis_angles!(rachis_node, leaf_rank, rachis_length, height_cpoint, width_cpoint, zenithal_cpoint_angle, fresh_biomass, parameters; rng)\n\nUpdate the angles and dimensions of the rachis segments based on biomechanical properties. This function is called when the rachis exists already, but needs updating its angles and dimensions  following a change in the leaf rank, length, or fresh biomass.\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.update_segment_angles!-NTuple{5, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.update_segment_angles!","text":"update_segment_angles!(leaflet, young_modulus, initial_angle, leaflet_length, tapering)\n\nUpdate the zenithal angles of each segment in a leaflet based on the Young's modulus model.\n\nArguments\n\nleaflet: The leaflet MTG node containing segments\nyoung_modulus: Value of Young's modulus\ninitial_angle: Initial angle from vertical in radians\nleaflet_length: Total length of the leaflet\ntapering: Tapering factor\n\nReturns\n\nNothing (the angles are updated in place)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.width_at_cpoint-Tuple{Any, Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.width_at_cpoint","text":"width_at_cpoint(rachis_length, cpoint_width_intercept, cpoint_width_slope)\n\nCompute width at C point based on rachis length.\n\nArguments\n\nrachis_length: Length of rachis (m)\ncpoint_width_intercept: Intercept of linear function (m)\ncpoint_width_slope: Slope of linear function\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.write_parameters-Tuple{Any, Any}","page":"XPalm.VPalm API","title":"XPalm.VPalm.write_parameters","text":"write_parameters(file, params)\n\nWrite the given parameters to a file using YAML format.\n\nArguments\n\nfile: The file path to write the parameters to.\nparams: The parameters to be written.\n\nExample\n\nfile = joinpath(dirname(dirname(pathof(VPalm))),\"test\",\"files\",\"parameter_file.yml\")\nparams = read_parameters(file)\nwrite_parameters(tempname(), params)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.xyz_to_dist_and_angles-Union{Tuple{AbstractVector{P}}, Tuple{P}} where P<:Meshes.Point","page":"XPalm.VPalm API","title":"XPalm.VPalm.xyz_to_dist_and_angles","text":"xyz_to_dist_and_angles(points)\n\nCompute segment lengths and angles from point coordinates.\n\nArguments\n\npoints: A vector of Meshes.Points.\n\nReturns\n\nA NamedTuple with fields:\ndist_p2p1: Vector of segment lengths (m).\nvangle_xy: Vector of angles between the segment and the XY plane (radians).\nvangle_xz: Vector of angles between the segment and the XZ plane (radians).\n\n\n\n\n\n","category":"method"},{"location":"vpalm/api/#XPalm.VPalm.@check_unit","page":"XPalm.VPalm API","title":"XPalm.VPalm.@check_unit","text":"@check_unit(variable, expected_unit, [verbose=true])\n\nCheck if a variable has the expected unit type. If no unit is found, assign the expected unit. If a different unit is found, try to convert to the expected unit.\n\nArguments\n\nvariable: The variable to check\nexpected_unit: The expected unit (e.g., u\"m\")\nverbose: Whether to show warnings (default: true)\n\nExamples\n\n```julia rachislength = 10 @checkunit rachis_length u\"m\"  # Will add u\"m\" and warn\n\npetiolelength = 10 @checkunit petiole_length u\"m\" false # Will add u\"m\" without a warning\n\nmass = 5.0u\"g\" @check_unit mass u\"kg\"   # Will convert g to kg\n\n\n\n\n\n","category":"macro"},{"location":"api/#XPalm-core-functions","page":"XPalm API","title":"XPalm core functions","text":"","category":"section"},{"location":"api/","page":"XPalm API","title":"XPalm API","text":"Documentation for the main functions of the XPalm package.","category":"page"},{"location":"api/#XPalm.Palm","page":"XPalm API","title":"XPalm.Palm","text":"Palm(;\n    nsteps=1,\n    initiation_age=0,\n    parameters=default_parameters(),\n    model_list=model_mapping(parameters, nsteps)\n)\n\nCreate a new scene with one Palm plant.\n\nArguments\n\nnsteps: number of time steps to run the simulation for (default: 1, should match the number of rows in the meteo data)\ninitiation_age: date of the first phytomer initiation (default: 0)\nparameters: a dictionary of parameters (default: default_parameters())\nmodel_list: a dictionary of models (default: model_mapping(parameters, nsteps))\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Palm-Tuple{}","page":"XPalm API","title":"XPalm.Palm","text":"Palm(; initiation_age=0, parameters=default_parameters())\n\nCreate a new scene with one Palm plant. The scene contains a soil, a plant, a root system, a stem, a phytomer, an internode, and a leaf.\n\nArguments\n\ninitiation_age: days elapsed since the first phytomer initiation (default: 0)\nparameters: a dictionary of parameters (default: default_parameters())\n\nReturns\n\na Palm object\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.age_relative_value-NTuple{5, Any}","page":"XPalm API","title":"XPalm.age_relative_value","text":"age_relative_value(age, age_min_value, age_max_value, min_value, max_value)\n\nValue that depends on the plant age.\n\nArguments\n\nage: the current age of the plant\nage_min_value: the age at which minimum value is reached (ages below this age will hage min_value)\nage_max_value: the age at which the value is at the maximum value (ages above this age will hage max_value)\nmin_value: the value below or at age_min_value\nmax_value: the value at or above age_max_value\n\nExamples\n\njulia> XPalm.age_relative_value(0, 1, 10, 0.1, 0.8)\n0.1\n\njulia> XPalm.age_relative_value(5, 1, 10, 0.1, 0.8)\n0.4111111111111111\n\njulia> XPalm.age_relative_value(15, 1, 10, 0.1, 0.8)\n0.8\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.model_mapping-Tuple{Any}","page":"XPalm API","title":"XPalm.model_mapping","text":"model_mapping(p; architecture=false)\n\nDefines the list of sub-models used in XPalm.\n\nArguments\n\np: A palm object with the parameters of the model (e.g. p = Palm()).\narchitecture: A boolean indicating whether to compute the 3D architecture of the palm (default is false).\n\nReturns\n\nA multiscale list of models, as a dictionary of scale (keys) and list of models (values).\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.notebook","page":"XPalm API","title":"XPalm.notebook","text":"notebook(copyto::String; force::Bool)\n\nOpen an XPalm notebook or create one from a template at path, and run the notebook.\n\nArguments\n\npath::String: The path to the notebook file. If it exists, it will be opened (unless force=true), otherwise it will be created.\nforce::Bool=false: If true, overwrite the file at path.\n\nExample\n\nusing XPalm, Pluto\nXPalm.notebook()\n\n\n\n\n\n","category":"function"},{"location":"api/#XPalm.xpalm-Tuple{Any, Any}","page":"XPalm API","title":"XPalm.xpalm","text":"xpalm(meteo; vars=Dict(\"Scene\" => (:lai,)), architecture=false, palm=Palm(initiation_age=0, parameters=default_parameters()))\nxpalm(meteo, sink; vars=Dict(\"Scene\" => (:lai,)), architecture=false, palm=Palm(initiation_age=0, parameters=default_parameters()))\n\nRun the XPalm model with the given meteo data and return the results in a DataFrame.\n\nArguments\n\nmeteo: DataFrame with the meteo data\nsink: a Tables.jl compatible sink function to format the results, for exemple a DataFrame\nvars: A dictionary with the outputs to be returned for each scale of simulation\narchitecture: A boolean indicating whether to compute the 3D architecture of the palm (default is false)\npalm: the Palm object with the parameters of the model\n\nReturns\n\nA simulation output, either as a dictionary of variables per scales (default) or as a Tables.jl formatted object.\n\nExample\n\nusing XPalm, CSV, DataFrames\nmeteo = CSV.read(joinpath(dirname(dirname(pathof(XPalm))), \"0-data/meteo.csv\"), DataFrame)\ndf = xpalm(meteo, DataFrame; vars= Dict(\"Scene\" => (:lai,)))\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm-Models","page":"XPalm API","title":"XPalm Models","text":"","category":"section"},{"location":"api/","page":"XPalm API","title":"XPalm API","text":"Documentation for the models available in XPalm.","category":"page"},{"location":"api/#XPalm.Models.AbortionRate","page":"XPalm API","title":"XPalm.Models.AbortionRate","text":"AbortionRate(TT_flowering, duration_abortion, abortion_rate_max=1.0, abortion_rate_ref=0.2; random_seed::Int=0)\nAbortionRate(TT_flowering, duration_abortion, abortion_rate_max, abortion_rate_ref, random_generator<:AbstractRNG)\n\nDetermines if the inflorescence will abort based on the trophic state of the plant during a given period in thermal time.\n\nArguments\n\nTT_flowering: thermal time for flowering since phytomer appearence (degree days).\nduration_abortion: duration used for computing abortion rate before flowering (degree days).\n\nInputs\n\ncarbon_offer_after_rm: carbon offer after maintenance respiration (gC/plant).\ncarbon_demand_organs: carbon demand of all organs (gC/plant).\n\nOutputs\n\ncarbon_demand_plant: total carbon demand of the plant (gC/plant).\ncarbon_offer_plant: total carbon offer of the plant (gC/plant).\nstate: phytomer state (undetermined,Aborted,...)\n\nNote\n\nThe abortion is determined at TT_flowering based on the trophic_status of the plant during a period of time before this date. The hypothesis is that a trophic stress can trigger more abortion in the plant.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractAbortionModel","page":"XPalm API","title":"XPalm.Models.AbstractAbortionModel","text":"abortion process abstract model. \n\nAll models implemented to simulate the abortion process must be a subtype of this type, e.g.  struct MyAbortionModel <: AbstractAbortionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractAbortionModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractBiomassModel","page":"XPalm API","title":"XPalm.Models.AbstractBiomassModel","text":"biomass process abstract model. \n\nAll models implemented to simulate the biomass process must be a subtype of this type, e.g.  struct MyBiomassModel <: AbstractBiomassModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractBiomass_From_AreaModel","page":"XPalm API","title":"XPalm.Models.AbstractBiomass_From_AreaModel","text":"biomass_from_area process abstract model. \n\nAll models implemented to simulate the biomass_from_area process must be a subtype of this type, e.g.  struct MyBiomass_From_AreaModel <: AbstractBiomass_From_AreaModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBiomass_From_AreaModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractBiomass_To_AreaModel","page":"XPalm API","title":"XPalm.Models.AbstractBiomass_To_AreaModel","text":"biomass_to_area process abstract model. \n\nAll models implemented to simulate the biomass_to_area process must be a subtype of this type, e.g.  struct MyBiomass_To_AreaModel <: AbstractBiomass_To_AreaModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBiomass_To_AreaModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractCarbon_AllocationModel","page":"XPalm API","title":"XPalm.Models.AbstractCarbon_AllocationModel","text":"carbon_allocation process abstract model. \n\nAll models implemented to simulate the carbon_allocation process must be a subtype of this type, e.g.  struct MyCarbon_AllocationModel <: AbstractCarbon_AllocationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AllocationModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractCarbon_AssimilationModel","page":"XPalm API","title":"XPalm.Models.AbstractCarbon_AssimilationModel","text":"carbon_assimilation process abstract model. \n\nAll models implemented to simulate the carbon_assimilation process must be a subtype of this type, e.g.  struct MyCarbon_AssimilationModel <: AbstractCarbon_AssimilationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AssimilationModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractCarbon_DemandModel","page":"XPalm API","title":"XPalm.Models.AbstractCarbon_DemandModel","text":"carbon_demand process abstract model. \n\nAll models implemented to simulate the carbon_demand process must be a subtype of this type, e.g.  struct MyCarbon_DemandModel <: AbstractCarbon_DemandModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_DemandModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractCarbon_OfferModel","page":"XPalm API","title":"XPalm.Models.AbstractCarbon_OfferModel","text":"carbon_offer process abstract model. \n\nAll models implemented to simulate the carbon_offer process must be a subtype of this type, e.g.  struct MyCarbon_OfferModel <: AbstractCarbon_OfferModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_OfferModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractFTSWModel","page":"XPalm API","title":"XPalm.Models.AbstractFTSWModel","text":"AbstractFTSWModel <: AbstractSoil_WaterModel\n\nDefines a structure for soil water model that computes ftsw as an output.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractFinal_Potential_BiomassModel","page":"XPalm API","title":"XPalm.Models.AbstractFinal_Potential_BiomassModel","text":"final_potential_biomass process abstract model. \n\nAll models implemented to simulate the final_potential_biomass process must be a subtype of this type, e.g.  struct MyFinal_Potential_BiomassModel <: AbstractFinal_Potential_BiomassModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractFinal_Potential_BiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractHarvestModel","page":"XPalm API","title":"XPalm.Models.AbstractHarvestModel","text":"harvest process abstract model. \n\nAll models implemented to simulate the harvest process must be a subtype of this type, e.g.  struct MyHarvestModel <: AbstractHarvestModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractHarvestModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractInitiation_AgeModel","page":"XPalm API","title":"XPalm.Models.AbstractInitiation_AgeModel","text":"initiation_age process abstract model. \n\nAll models implemented to simulate the initiation_age process must be a subtype of this type, e.g.  struct MyInitiation_AgeModel <: AbstractInitiation_AgeModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractInitiation_AgeModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractInternode_DimensionsModel","page":"XPalm API","title":"XPalm.Models.AbstractInternode_DimensionsModel","text":"internode_dimensions process abstract model. \n\nAll models implemented to simulate the internode_dimensions process must be a subtype of this type, e.g.  struct MyInternode_DimensionsModel <: AbstractInternode_DimensionsModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractInternode_DimensionsModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractInternode_Final_Potential_DimensionsModel","page":"XPalm API","title":"XPalm.Models.AbstractInternode_Final_Potential_DimensionsModel","text":"internode_final_potential_dimensions process abstract model. \n\nAll models implemented to simulate the internode_final_potential_dimensions process must be a subtype of this type, e.g.  struct MyInternode_Final_Potential_DimensionsModel <: AbstractInternode_Final_Potential_DimensionsModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractInternode_Final_Potential_DimensionsModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractInternode_Potential_DimensionsModel","page":"XPalm API","title":"XPalm.Models.AbstractInternode_Potential_DimensionsModel","text":"internode_potential_dimensions process abstract model. \n\nAll models implemented to simulate the internode_potential_dimensions process must be a subtype of this type, e.g.  struct MyInternode_Potential_DimensionsModel <: AbstractInternode_Potential_DimensionsModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractInternode_Potential_DimensionsModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLai_DynamicModel","page":"XPalm API","title":"XPalm.Models.AbstractLai_DynamicModel","text":"lai_dynamic process abstract model. \n\nAll models implemented to simulate the lai_dynamic process must be a subtype of this type, e.g.  struct MyLai_DynamicModel <: AbstractLai_DynamicModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLai_DynamicModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLeaf_AreaModel","page":"XPalm API","title":"XPalm.Models.AbstractLeaf_AreaModel","text":"leaf_area process abstract model. \n\nAll models implemented to simulate the leaf_area process must be a subtype of this type, e.g.  struct MyLeaf_AreaModel <: AbstractLeaf_AreaModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_AreaModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLeaf_Final_Potential_AreaModel","page":"XPalm API","title":"XPalm.Models.AbstractLeaf_Final_Potential_AreaModel","text":"leaf_final_potential_area process abstract model. \n\nAll models implemented to simulate the leaf_final_potential_area process must be a subtype of this type, e.g.  struct MyLeaf_Final_Potential_AreaModel <: AbstractLeaf_Final_Potential_AreaModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_Final_Potential_AreaModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLeaf_Potential_AreaModel","page":"XPalm API","title":"XPalm.Models.AbstractLeaf_Potential_AreaModel","text":"leaf_potential_area process abstract model. \n\nAll models implemented to simulate the leaf_potential_area process must be a subtype of this type, e.g.  struct MyLeaf_Potential_AreaModel <: AbstractLeaf_Potential_AreaModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_Potential_AreaModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLeaf_PruningModel","page":"XPalm API","title":"XPalm.Models.AbstractLeaf_PruningModel","text":"leaf_pruning process abstract model. \n\nAll models implemented to simulate the leaf_pruning process must be a subtype of this type, e.g.  struct MyLeaf_PruningModel <: AbstractLeaf_PruningModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_PruningModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLeaf_RankModel","page":"XPalm API","title":"XPalm.Models.AbstractLeaf_RankModel","text":"leaf_rank process abstract model. \n\nAll models implemented to simulate the leaf_rank process must be a subtype of this type, e.g.  struct MyLeaf_RankModel <: AbstractLeaf_RankModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_RankModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractLight_InterceptionModel","page":"XPalm API","title":"XPalm.Models.AbstractLight_InterceptionModel","text":"light_interception process abstract model. \n\nAll models implemented to simulate the light_interception process must be a subtype of this type, e.g.  struct MyLight_InterceptionModel <: AbstractLight_InterceptionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_InterceptionModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractMaintenance_RespirationModel","page":"XPalm API","title":"XPalm.Models.AbstractMaintenance_RespirationModel","text":"maintenance_respiration process abstract model. \n\nAll models implemented to simulate the maintenance_respiration process must be a subtype of this type, e.g.  struct MyMaintenance_RespirationModel <: AbstractMaintenance_RespirationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractMaintenance_RespirationModel)\n\nGeneric maintenance repspiration model. \n\nThe models used are defined by the types of the maintenance_respiration fields of a  ModelList.\n\nExamples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\n\n# Using Fvcb model:\nleaf =\n    ModelList(\n        maintenance_respiration = RmQ10(),\n        status = (Tₗ = 25.0, PPFD = 1000.0, Cₛ = 400.0, Dₗ = meteo.VPD)\n    )\n\nmaintenance_respiration(leaf, meteo)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractNumber_FruitsModel","page":"XPalm API","title":"XPalm.Models.AbstractNumber_FruitsModel","text":"number_fruits process abstract model. \n\nAll models implemented to simulate the number_fruits process must be a subtype of this type, e.g.  struct MyNumber_FruitsModel <: AbstractNumber_FruitsModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractNumber_FruitsModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractNumber_SpikeletsModel","page":"XPalm API","title":"XPalm.Models.AbstractNumber_SpikeletsModel","text":"number_spikelets process abstract model. \n\nAll models implemented to simulate the number_spikelets process must be a subtype of this type, e.g.  struct MyNumber_SpikeletsModel <: AbstractNumber_SpikeletsModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractNumber_SpikeletsModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractPhyllochronModel","page":"XPalm API","title":"XPalm.Models.AbstractPhyllochronModel","text":"phyllochron process abstract model. \n\nAll models implemented to simulate the phyllochron process must be a subtype of this type, e.g.  struct MyPhyllochronModel <: AbstractPhyllochronModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractPhyllochronModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractPhytomer_CountModel","page":"XPalm API","title":"XPalm.Models.AbstractPhytomer_CountModel","text":"phytomer_count process abstract model. \n\nAll models implemented to simulate the phytomer_count process must be a subtype of this type, e.g.  struct MyPhytomer_CountModel <: AbstractPhytomer_CountModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractPhytomer_CountModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractPhytomer_EmissionModel","page":"XPalm API","title":"XPalm.Models.AbstractPhytomer_EmissionModel","text":"phytomer_emission process abstract model. \n\nAll models implemented to simulate the phytomer_emission process must be a subtype of this type, e.g.  struct MyPhytomer_EmissionModel <: AbstractPhytomer_EmissionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractPhytomer_EmissionModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractPlant_AgeModel","page":"XPalm API","title":"XPalm.Models.AbstractPlant_AgeModel","text":"plant_age process abstract model. \n\nAll models implemented to simulate the plant_age process must be a subtype of this type, e.g.  struct MyPlant_AgeModel <: AbstractPlant_AgeModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractPlant_AgeModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractPotential_EvapotranspirationModel","page":"XPalm API","title":"XPalm.Models.AbstractPotential_EvapotranspirationModel","text":"potential_evapotranspiration process abstract model. \n\nAll models implemented to simulate the potential_evapotranspiration process must be a subtype of this type, e.g.  struct MyPotential_EvapotranspirationModel <: AbstractPotential_EvapotranspirationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractPotential_EvapotranspirationModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractReproductive_Organ_EmissionModel","page":"XPalm API","title":"XPalm.Models.AbstractReproductive_Organ_EmissionModel","text":"reproductive_organ_emission process abstract model. \n\nAll models implemented to simulate the reproductive_organ_emission process must be a subtype of this type, e.g.  struct MyReproductive_Organ_EmissionModel <: AbstractReproductive_Organ_EmissionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractReproductive_Organ_EmissionModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractReserve_FillingModel","page":"XPalm API","title":"XPalm.Models.AbstractReserve_FillingModel","text":"reserve_filling process abstract model. \n\nAll models implemented to simulate the reserve_filling process must be a subtype of this type, e.g.  struct MyReserve_FillingModel <: AbstractReserve_FillingModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractReserve_FillingModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractRoot_GrowthModel","page":"XPalm API","title":"XPalm.Models.AbstractRoot_GrowthModel","text":"root_growth process abstract model. \n\nAll models implemented to simulate the root_growth process must be a subtype of this type, e.g.  struct MyRoot_GrowthModel <: AbstractRoot_GrowthModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractRoot_GrowthModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractSex_DeterminationModel","page":"XPalm API","title":"XPalm.Models.AbstractSex_DeterminationModel","text":"sex_determination process abstract model. \n\nAll models implemented to simulate the sex_determination process must be a subtype of this type, e.g.  struct MySex_DeterminationModel <: AbstractSex_DeterminationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractSex_DeterminationModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractSoil_WaterModel","page":"XPalm API","title":"XPalm.Models.AbstractSoil_WaterModel","text":"soil_water process abstract model. \n\nAll models implemented to simulate the soil_water process must be a subtype of this type, e.g.  struct MySoil_WaterModel <: AbstractSoil_WaterModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractSoil_WaterModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractStateModel","page":"XPalm API","title":"XPalm.Models.AbstractStateModel","text":"state process abstract model. \n\nAll models implemented to simulate the state process must be a subtype of this type, e.g.  struct MyStateModel <: AbstractStateModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractStateModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.AbstractThermal_TimeModel","page":"XPalm API","title":"XPalm.Models.AbstractThermal_TimeModel","text":"thermal_time process abstract model. \n\nAll models implemented to simulate the thermal_time process must be a subtype of this type, e.g.  struct MyThermal_TimeModel <: AbstractThermal_TimeModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractThermal_TimeModel)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.Beer","page":"XPalm API","title":"XPalm.Models.Beer","text":"Beer(k)\n\nBeer-Lambert law for light interception.\n\nArguments\n\nk: extinction coefficient of light\n\nInputs\n\nlai in m² m⁻².\n\nRequired meteorology data\n\nRi_PAR_f: incident flux of atmospheric radiation in the PAR, in MJ m⁻² d⁻¹.\n\nOutputs\n\naPPFD: absorbed Photosynthetic Photon Flux Density in mol[PAR] m[soil]⁻² d⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.CarbonOfferRm","page":"XPalm API","title":"XPalm.Models.CarbonOfferRm","text":"CarbonOfferRm()\n\nA model that computes carbon offer as the carbon assimilation minus the  maintenance respiration.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.ConstantRUEModel","page":"XPalm API","title":"XPalm.Models.ConstantRUEModel","text":"ConstantRUEModel(rue)\n\nComputes the carbon_assimilation using a constant radiation use efficiency (rue).\n\nArguments\n\nrue: radiation use efficiency (gC MJ⁻¹)\n\nInputs\n\naPPFD: the absorbed Photosynthetic Photon Flux Density in mol[PAR] m[leaf]⁻² s⁻¹.\n\nOutputs\n\ncarbon_assimilation: carbon offer from photosynthesis\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.DailyDegreeDays","page":"XPalm API","title":"XPalm.Models.DailyDegreeDays","text":"DailyDegreeDays(TOpt1, TOpt2, TBase, TLim)\nDailyDegreeDays(TOpt1=25, TOpt2=30, TBase=15, TLim=40)\n\nCompute thermal time from daily meteo data\n\nArguments\n\nTOpt1: starting optimal temperature for thermal time calculation (degree Celsius)\nTOpt2: ending optimal temperature for thermal time calculation (degree Celsius)\nTBase: Tbase temperature for thermal time calculation (degree Celsius)\nTLim: limit temperature for thermal time calculation (degree Celsius)\n\nOutputs\n\nTEff: daily efficient temperature for plant growth (degree C days) \n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.DailyDegreeDaysSinceInit","page":"XPalm API","title":"XPalm.Models.DailyDegreeDaysSinceInit","text":"DailyDegreeDaysSinceInit()\n\nCompute thermal time since organ initiation using :TEff.\n\nOutputs\n\nTT_since_init: daily efficient temperature for organ growth (degree C days)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.DailyPlantAgeModel","page":"XPalm API","title":"XPalm.Models.DailyPlantAgeModel","text":"DailyPlantAgeModel(initiation_age)\n\nPlant age model, simply tracks the age of the plant in days.\n\nArguments\n\ninitiation_age: age of the plant at the start of the simulation (days)\n\nReturns\n\nage: age of the plant (days)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.DegreeDaysFTSW","page":"XPalm API","title":"XPalm.Models.DegreeDaysFTSW","text":"DegreeDaysFTSW(TOpt1, TOpt2, TBase, TLim, threshold_ftsw_stress)\nDegreeDaysFTSW(TOpt1=25, TOpt2=30, TBase=15, TLim=40, threshold_ftsw_stress=0.3)\n\nCompute thermal time from daily meteo data, corrected by FTSW\n\nArguments\n\nTOpt1: starting optimal temperature for thermal time calculation (degree Celsius)\nTOpt2: ending optimal temperature for thermal time calculation (degree Celsius)\nTBase: Tbase temperature for thermal time calculation (degree Celsius)\nTLim: limit temperature for thermal time calculation (degree Celsius)\nthreshold_ftsw_stress: threshold value under which we apply an FTSW stress\n\nInputs\n\nftsw: fraction of transpirable soil water (unitless)\n\nOuputs\n\nTEff: daily efficient temperature for plant growth (degree C days) \nTT_since_init: cumulated thermal time from the first day (degree C days)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.ET0_BP","page":"XPalm API","title":"XPalm.Models.ET0_BP","text":"ET0_BP(LATITUDE,ALTITUDE)\nET0_BP(LATITUDE=0.97,ALTITUDE=50)\n\nCompute potential evapotranspiration \n\nArguments\n\nLATITUDE: latitude (radian)\nALTITUDE: altitude (m)\n\nInputs\n\nmeteo\n\nOutputs\n\nET0: potential evapotranpiration (mm)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.FTSW","page":"XPalm API","title":"XPalm.Models.FTSW","text":"FTSW(;\n    ini_root_depth,\n    H_FC=0.23,\n    H_WP_Z1=0.05,\n    Z1=200.0,\n    H_WP_Z2=0.05,\n    Z2=2000.0,\n    H_0=0.15,\n    KC=1.0,\n    TRESH_EVAP=0.5,\n    TRESH_FTSW_TRANSPI=0.5,\n)\n\nFraction of Transpirable Soil Water model.\n\nNote that there is also a method for FTSW that takes an organ type as type, e.g. FTSW{Leaf}(ini_root_depth = 200.0).\n\nArguments\n\nini_root_depth: root depth at initialization (mm)\nH_FC: Humidity at field capacity (g[H20] g[Soil])\nH_WP_Z1: Humidity at wilting point (g[H20] g[Soil]) for the first layer\nZ1: Thickness of the first layer (mm)\nH_WP_Z2: Humidity at wilting point (g[H20] g[Soil]) for the second layer\nZ2: Thickness of the second layer (mm)\nH_0: Initial soil humidity (g[H20] g[Soil])\nKC: crop coefficient (unitless)\nTRESH_EVAP: fraction of water content in the evaporative layer below which evaporation is reduced (g[H20] g[Soil])\nTRESH_FTSW_TRANSPI: FTSW treshold below which transpiration is reduced (g[H20] g[Soil])\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.FTSW_BP","page":"XPalm API","title":"XPalm.Models.FTSW_BP","text":"FTSW_BP(H_FC::Float64, H_WP_Z1::Float64,Z1::Float64,H_WP_Z2::Float64,Z2::Float64,H_0::Float64,KC::Float64,TRESH_EVAP::Float64,TRESH_FTSW_TRANSPI::Float64)\n\nFraction of Transpirable Soil Water model.\n\nArguments\n\nini_root_depth: root depth at initialization (mm)\nH_FC: Humidity at field capacity (g[H20] g[Soil])\nH_WP_Z1: Humidity at wilting point (g[H20] g[Soil]) for the first layer\nZ1: Thickness of the first layer (mm)\nH_WP_Z2: Humidity at wilting point (g[H20] g[Soil]) for the second layer\nZ2: Thickness of the second layer (mm)\nH_0: Initial soil humidity (g[H20] g[Soil])\nKC: cultural coefficient (unitless)\nTRESH_EVAP: fraction of water content in the evaporative layer below which evaporation is reduced (g[H20] g[Soil])\nTRESH_FTSW_TRANSPI: FTSW treshold below which transpiration is reduced (g[H20] g[Soil])\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.FemaleBiomass","page":"XPalm API","title":"XPalm.Models.FemaleBiomass","text":"FemaleBiomass(respirationcost,respirationcostoleosynthesis) FemaleBiomass(respirationcost=1.44,respirationcostoleosynthesis=3.2)\n\nCompute female biomass (inflo and bunch) from daily carbon allocation. Allocation to the different components of the bunch (stalk adnd fruit) is proportional to their carbon demand.\n\nArguments\n\nrespiration_cost: respiration cost  (g g-1)\nrespiration_cost_oleosynthesis: respiration cost of fruits oil  (g g-1)\n\ninputs\n\ncarbon_allocation: carbon allocated to female inflo\ncarbon_demand_stalk: carbon demand of the stalk\ncarbon_demand_non_oil: carbon demand of non oil components of fruits\ncarbon_demand_oil: carbon demand of fruits oil\nstate: state of the inflorescence \n\noutputs\n\nbiomass: total ifnlo/bunch biomass\nbiomass_stalk: stalk biomass\nbiomass_fruits: fruits biomass\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.FemaleCarbonDemandModel","page":"XPalm API","title":"XPalm.Models.FemaleCarbonDemandModel","text":"FemaleCarbonDemandModel(\n    respiration_cost,\n    respiration_cost_oleosynthesis,\n    TT_flowering,\n    TT_fruiting,\n    duration_bunch_development,\n    duration_oleosynthesis,\n    duration_dev_stalk,\n)\n\nFemaleCarbonDemandModel(;\n    respiration_cost=1.44,\n    respiration_cost_oleosynthesis=3.2,\n    TT_flowering=10530.0,\n    duration_bunch_development=1215.0,\n    duration_fruit_setting=405.0,\n    fraction_period_oleosynthesis=0.8,\n    fraction_period_stalk=0.2\n)\n\nCarbon demand of the female inflorescence based on the potential fruit biomass\n\nArguments\n\nrespiration_cost: growth respiration cost (g g⁻¹)\nrespiration_cost_oleosynthesis: respiration cost during oleosynthesis (g g⁻¹)\nTT_flowering: thermal time for flowering since phytomer appearance (degree days).\nTT_fruiting: thermal time for fruit setting since phytomer appearance (degree days).\nduration_bunch_development: duration between fruit set and bunch maturity (ready for harvest) (degree days).\nduration_oleosynthesis: duration of oleosynthesis (degree days).\nduration_dev_stalk: duration of stalk development (degree days).\nduration_fruit_setting: period of thermal time after flowering that determines the number of flowers in the bunch that become fruits, i.e. fruit set (degree days).\nfraction_period_oleosynthesis: fraction of the duration between flowering and harvesting when oleosynthesis occurs\nfraction_period_stalk: fraction of the duration between flowering and harvesting when stalk development occurs\n\nInputs\n\nfinal_potential_biomass_non_oil_fruit: potential fruit biomass that is not oil (g fruit-1)\nfinal_potential_biomass_oil_fruit: potential oil biomass in the fruit (g fruit-1)\nTEff: daily effective temperature (°C)\nTT_since_init: thermal time since the first day of the phytomer (degree days)\nstate: state of the leaf\n\nOutputs\n\ncarbon_demand: total carbon demand (g[sugar])\ncarbon_demand_oil: carbon demand for oil production (g[sugar])\ncarbon_demand_non_oil: carbon demand for non-oil production (g[sugar])\ncarbon_demand_stalk: carbon demand for stalk development (g[sugar])\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.FemaleFinalPotentialFruits","page":"XPalm API","title":"XPalm.Models.FemaleFinalPotentialFruits","text":"FemaleFinalPotentialFruits(;\n    days_increase_number_fruits=2379,\n    days_maximum_number_fruits=6500,\n    fraction_first_female=0.3,\n    potential_fruit_number_at_maturity=2000,\n    potential_fruit_weight_at_maturity=6.5,\n    stalk_max_biomass=2100.0,\n    oil_content=0.25\n)\n\nArguments\n\ndays_increase_number_fruits: age at which the number of fruits starts to increase (days)\ndays_maximum_number_fruits: age at which the palm makes bunch of mature size with the highest number of fruits (days).\nfraction_first_female: size of the first bunches on a young palm relative to the size \n\nat maturity (dimensionless)\n\npotential_fruit_number_at_maturity: potential number of fruits at maturity (number of fruits)\npotential_fruit_weight_at_maturity: potential weight of one fruit at maturity (g)\nstalk_max_biomass: maximum biomass of the stalk (g)\noil_content: oil content in the fruit (g oil g⁻¹ fruit)\n\nInputs\n\ninitiation_age: age at which the palm starts to make bunches (days)\n\nOutputs\n\npotential_fruits_number: potential number of fruits (number of fruits)\nfinal_potential_fruit_biomass: potential biomass of fruits (g)\nfinal_potential_biomass_stalk: potential biomass of stalk (g)\n\nExamples\n\nusing PlantSimEngine\nusing MultiScaleTreeGraph\nusing XPalm\nusing XPalm.Models \n\nnode = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\npot_model = FemaleFinalPotentialFruits(8.0 * 365, 0.3, 2000.0, 6.5, 2100.0)\n\nm = ModelList(\n    pot_model,\n    status = (initiation_age = 5000.0, )\n)\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nrun!(m, meteo, PlantMeteo.Constants(), node)\n\nm[:potential_fruits_number]\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.GraphNodeCount","page":"XPalm API","title":"XPalm.Models.GraphNodeCount","text":"GraphNodeCount(graph_node_count_ini=0)\n\nStores the number of nodes in the graph.\n\nArguments\n\ngraph_node_count_ini: the initial number of nodes in the graph.\n\nOutputs\n\ngraph_node_count: the number of nodes in the graph.\n\nDetails\n\nThis model does nothing. It is just used to define the value of the graph's node count so it exists in the status of the organ.\n\nThe node cound should be updated by the models that create new organs at the time-step of organ emission.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.InternodeBiomass","page":"XPalm API","title":"XPalm.Models.InternodeBiomass","text":"InternodeBiomass(respirationcost) InternodeBiomass(respirationcost=1.44)\n\nCompute internode biomass from daily carbon allocation\n\nArguments\n\ninitial_biomass: initial biomass of the internode (g)\nrespiration_cost: repisration cost  (g g-1)\n\nInputs\n\ncarbon_allocation:carbon allocated to the internode\n\nOutputs\n\nbiomass: internode biomass (g)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.InternodeCarbonDemandModel","page":"XPalm API","title":"XPalm.Models.InternodeCarbonDemandModel","text":"InternodeCarbonDemandModel(; apparentdensitydry=300000.0, carbonconcentration=0.5, respirationcost=1.44)\n\nCompute internode carbon demand from potential dimensions\n\nArguments\n\napparent_density: stem apparent density of dry matter (g[dry mass] m⁻³).\ncarbon_concentration: carbon concentration in the stem (g[C] g[dry mass]⁻¹). \nrespiration_cost: repisration cost  (g[sugar].g[carbon mass]-1)\n\nNotes\n\nThe stem apparent density is transformed into a carbon density by multiplying it by the carbon concentration.\n\nInputs\n\npotential_height: potential height of the internode (m)\npotential_radius: potential radius of the internode (m)\n\nOutputs\n\npotential_volume: potential volume of the internode (m³)\ncarbon_demand: daily carbon demand of the internode (g[sugar])\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.LAIModel","page":"XPalm API","title":"XPalm.Models.LAIModel","text":"LAIModel()\n\nCompute the leaf area index (LAI) using all leaves in the scene and the scene surface area.\n\nArguments\n\narea: the surface area of the scene.\n\nInputs\n\nleaf_areas: a vector of all leaf area values in the scene (from each leaf, or each plant)\n\nOutputs\n\nleaf_area: the total leaf area of the scene (m²)\nlai: the leaf area index (m² m⁻²)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.LeafAreaModel","page":"XPalm API","title":"XPalm.Models.LeafAreaModel","text":"LeafAreaModel(lma_min, leaflets_biomass_contribution, leaf_area_ini)\n\nLeaf area from its biomass.\n\nArguments\n\nlma_min: minimal leaf mass area (when there is no reserve in the leaf)\nleaflets_biomass_contribution: ratio of leaflets biomass to total leaf biomass including rachis and petiole (0-1)\n\nInputs\n\nbiomass: leaf biomass (g)\n\nOutputs\n\nleaf_area: leaf area (m2)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.LeafCarbonDemandModelArea","page":"XPalm API","title":"XPalm.Models.LeafCarbonDemandModelArea","text":"LeafCarbonDemandModelArea(lma_min, respiration_cost, leaflets_biomass_contribution)\n\nCarbon demand of the leaf based on the difference between the current leaf area and the  potential leaf area.\n\nThis model assumes that the leaf is always trying to catch its potential growth, so  leaf demand can increase more than the daily potential to alleviate any previous stress effect.\n\nSee also LeafCarbonDemandModelPotentialArea.\n\nArguments\n\nlma_min: minimum leaf mass area (g m⁻²)\nrespiration_cost: growth respiration cost (g g⁻¹)\nleaflets_biomass_contribution: contribution of the leaflet biomass to the total leaf biomass (including rachis)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.LeafStateModel","page":"XPalm API","title":"XPalm.Models.LeafStateModel","text":"LeafStateModel()\n\nGive the state of the leaf \n\nArguments\n\nNone\n\nInputs\n\nmaturity: a leaf is mature when it reaches its final length\nstate_phytomers: state of the phytomers (multiscale variable)\n\nOutputs\n\nstate: leaf state (\"undetermined\", \"Opened\", \"Pruned\")\nrank_leaves: rank of all leaves\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.MaleBiomass","page":"XPalm API","title":"XPalm.Models.MaleBiomass","text":"MaleBiomass(respirationcost) MaleBiomass(respirationcost=1.44)\n\nCompute male biomass  from daily carbon allocation\n\nArguments\n\nrespiration_cost: respiration cost  (g g-1)\n\ninputs\n\ncarbon_allocation: carbon allocated to female inflo\nstate: state of the inflorescence \n\noutputs\n\nbiomass: inflo biomass\nlitter_male: biomass of senescent inflorescent that goes to the litter \n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.MaleFinalPotentialBiomass","page":"XPalm API","title":"XPalm.Models.MaleFinalPotentialBiomass","text":"MaleFinalPotentialBiomass(male_max_biomass, age_mature_male, fraction_biomass_first_male)\n\nArguments\n\nmale_max_biomass: maximal biomass of a male (gC)\nage_mature_male: age at which the palm plant reaches a mature state for producing male inflorescences (days)\nfraction_biomass_first_male: fraction of the maximal biomass that first males can reach (dimensionless)\n\nInputs\n\ninitiation_age: age of the plant when the organ was initiated (days)\n\nOutputs\n\nfinal_potential_biomass: final potential biomass of the male inflorescence (gC)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.NumberFruits","page":"XPalm API","title":"XPalm.Models.NumberFruits","text":"NumberFruits(TT_flowering, duration_dev_fruits)\n\nDetermines the number of fruits on the bunch.\n\nArguments\n\nTT_flowering: thermal time for flowering since phytomer appearence (degree days).\nduration_fruit_setting: period of thermal time after flowering that determines the number of flowers in the bunch that become fruits, i.e. fruit set (degree days).\ncomputed: \n\nInputs\n\ncarbon_offer_plant: carbon offer maintenance respiration (gC/plant).\npotential_fruits_number: potential number of fruits (number/bunch).\ncarbon_demand_plant: carbon demand of the plant (gC/plant), used to compute the plant trophic status.\ncarbon_offer_plant: carbon offer of the plant (gC/plant), used to compute the plant trophic status.\n\nOutputs\n\nfruits_number: number of fruits (number/bunch).\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.NumberSpikelets","page":"XPalm API","title":"XPalm.Models.NumberSpikelets","text":"NumberSpikelets(TT_flowering=6300.0, duration_dev_spikelets=675.0)\n\nDetermines the number of spikelets on the fruit bunch.\n\nArguments\n\nTT_flowering: thermal time for flowering since phytomer appearence (degree days).\nduration_dev_spikelets: period of thermal time before flowering that determines the number of spikelets on the fruit bunch (degree days).\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.OrgansCarbonAllocationModel","page":"XPalm API","title":"XPalm.Models.OrgansCarbonAllocationModel","text":"OrgansCarbonAllocationModel()\n\nCompute the carbon to allocate to organs from photosysthesis and reserve mobilization (after maintenance respiration) \n\nArguments\n\ncost_reserve_mobilization: carbon cost to mobilize carbon reserve from stem or leaves\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.PhyllochronModel","page":"XPalm API","title":"XPalm.Models.PhyllochronModel","text":"PhyllochronModel(agepalmmaturity,productionspeedinitial,productionspeedmature)\n\nCompute the phyllochron and initiate a new phytomer at every new emergence. The phyllochron may be reduced by TEff if it is itself modulated by e.g. the available water in the soil.\n\nArguments\n\nage_palm_maturity: age of the plant when maturity is establiched (days)\nproduction_speed_initial: initial phyllochron (for seedlings) (leaf.degreeC days-1)\nproduction_speed_mature: phyllochron at plant maturity (leaf.degreeC days-1)\n\nInputs\n\nplant_age= plant age (days)\nTEff: daily efficient temperature for plant growth (degree C days) \n\nOutputs\n\nnewPhytomerEmergence: fraction of time during two successive phytomer (at 1 the new phytomer emerge)\nproduction_speed= phyllochron at the current plant age (leaf.degreeC days-1)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.PhytomerEmission","page":"XPalm API","title":"XPalm.Models.PhytomerEmission","text":"PhytomerEmission(mtg; phytomer_symbol=\"Phytomer\", internode_symbol=\"Internode\", leaf_symbol=\"Leaf\") <: AbstractPhytomer_EmissionModel\n\nA PhytomerEmission model, which emits a new phytomer when called. The new phytomer is composed of an internode and a leaf, and is added as a child of the last phytomer.\n\nArguments\n\nmtg::MultiScaleTreeGraph.Node: The multiscale tree graph of the plant.\nphytomer_symbol::String: The symbol of the phytomer, default to \"Phytomer\".\ninternode_symbol::String: The symbol of the internode, default to \"Internode\".\nleaf_symbol::String: The symbol of the leaf, default to \"Leaf\".\n\nInputs\n\ngraph_node_count::Int: The number of nodes in the graph.\n\nNo other inputs, except for the simulation object (sim_object) as the last argument to run!.\n\nOutputs\n\nlast_phytomer::MultiScaleTreeGraph.Node: The last phytomer of the palm, takes its values from the struct above as its first value.\nphytomer_count::Int: The number of phytomers in the palm.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.PlantLeafAreaModel","page":"XPalm API","title":"XPalm.Models.PlantLeafAreaModel","text":"PlantLeafAreaModel()\n\nSum of the leaf area at plant scale.\n\nInputs\n\nleaf_area_leaves: a vector of leaf area (m²)\nleaf_states: a vector of leaf states. Only leaves with state \"Opened\" are considered.\n\nOutputs\n\nleaf_area: total leaf area of the plant (m²)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.PlantRm","page":"XPalm API","title":"XPalm.Models.PlantRm","text":"PlantRm()\n\nTotal plant maintenance respiration based on the sum of Rm.\n\nIntputs\n\nRm_organs: a vector of maintenance respiration from all organs in the plant in gC d⁻¹\n\nOutputs\n\nRm: the total plant maintenance respiration in gC d⁻¹\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.PotentialAreaModel","page":"XPalm API","title":"XPalm.Models.PotentialAreaModel","text":"PotentialAreaModel(inflexion_index, slope)\nPotentialAreaModel(inflexion_index=  560.0, slope=100.0)\n\nComputes the instantaneous potential area at a given cumulative thermal time using  a logistic function. In other words, it defines the development of the leaf area at the potential, i.e. without any stress.  It starts around 0.0 and goes to a maximum of final_potential_area.\n\nArguments\n\ninflexion_index: a parameter that defines the relationship between the final potential\n\nleaf area and the inflexion point of the logistic function. The higher the final area, the  longer the time to reach the inflexion point.\n\nslope: the slope of the relationship at the inflexion point.\n\nInputs\n\nfinal_potential_area: the final potential area when the leaf is fully developed\nTT_since_init: the cumulated thermal time since leaf initiation\n\nOutputs\n\npotential_area: potential area of the leaf (m2)\nmaturity: maturity is true when the leaf reaches its final length\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.RUE_FTSW","page":"XPalm API","title":"XPalm.Models.RUE_FTSW","text":"ConstantRUEModel(rue)\n\nComputes the carbon_assimilation using a constant radiation use efficiency (rue).\n\nArguments\n\nrue: radiation use efficiency (gC MJ⁻¹)\n\nInputs\n\naPPFD: the absorbed Photosynthetic Photon Flux Density in mol[PAR] m[leaf]⁻² s⁻¹.\n\nOutputs\n\ncarbon_assimilation: carbon offer from photosynthesis\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.RankLeafPruning","page":"XPalm API","title":"XPalm.Models.RankLeafPruning","text":"RankLeafPruning(rank)\n\nFunction to remove leaf biomass and area when the phytomer has an harvested bunch or when the leaf reaches a treshold rank (below rank of harvested bunches) \n\nArguments\n\nrank: leaf rank treshold below whith the leaf is cutted\n\nInputs\n\nstate: phytomer state\n\nOutputs\n\nlitter_leaf: leaf biomass removed from the plantand going to the litter\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.ReproductiveOrganEmission","page":"XPalm API","title":"XPalm.Models.ReproductiveOrganEmission","text":"add_reproductive_organ!(...)\n\nAdd a new reproductive organ to a phytomer.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.RmQ10FixedN","page":"XPalm API","title":"XPalm.Models.RmQ10FixedN","text":"RmQ10FixedN(Q10, Mr, T_ref, P_alive)\nRmQ10FixedN(Q10, Turn, Prot, N, Gi, Mx, T_ref, P_alive)\n\nMaintenance respiration based on a Q10 computation with fixed nitrogen values  and proportion of living cells in the organs.\n\nSee those three references for more details:\n\nDufrene, Ochs, et Saugier, « Photosynthèse et productivité du palmier à huile en liaison avec les facteurs climatiques ». Wit, Simulation of Assimilation, Respiration and Transpiration of Crops; DE VRIES, « The Cost of Maintenance Processes in Plant Cells ». DE VRIES, « The Cost of Maintenance Processes in Plant Cells ».\n\nArguments\n\nQ10: Q10 factor (values should usually range between: 1.5 - 2.5, with 2.1 being the most common value)\nMr: maintenance respiration coefficient (gC gDM⁻¹). Should be around 0.06.\nT_ref: Reference temperature at which Q10 was measured (usually around 25.0°C)\nP_alive: proportion of living cells in the organ\nTurn: maintenance cost coefficient of the turnover of free proteins and membranes\nProt= 6.25: nitrogen to protein conversion coefficient\nN: nitrogen content of the organ (gN gDM⁻¹)\nGi: maintenance cost coefficient of the ionic gradient\nMx:mineral content of the organ (g gDM⁻¹)\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.RootGrowthFTSW","page":"XPalm API","title":"XPalm.Models.RootGrowthFTSW","text":"RootGrowthFTSW(TRESHFTSWSLOWROOTS, ROOTSGROWTHDEPTH, Z1, Z2) RootGrowthFTSW(TRESHFTSWSLOWROOTS=0.2, ROOTSGROWTHDEPTH=0.3, Z1=200, Z2=2000)\n\nCompute root growth depending on thermal time and water stress (ftsw)\n\nArguments\n\nini_root_depth: initial root depth (mm)\nROOTS_GROWTH_DEPTH: root growth in depth (mm.degreeC days-1)\nTRESH_FTSW_SLOW_ROOTS: ftsw treshold below which roots growth is reduced (unitless [0:1])\n\nThe model as a dependency on an AbstractFTSWModel that must return a value for ftsw, and soil_depth.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.SceneToPlantLightPartitioning","page":"XPalm API","title":"XPalm.Models.SceneToPlantLightPartitioning","text":"SceneToPlantLightPartitioning()\n\nPartitioning from aPPFD at the scene scale to the plant scale based on the relative  leaf area of the plant.\n\nArguments\n\nscene_area: the surface area of the scene (m⁻²) occupied by the plant.\n\nInputs\n\naPPFD: absorbed Photosynthetic Photon Flux Density in mol[PAR] m[soil]⁻² d⁻¹ (scene scale).\nleaf_area: the target plant leaf area\nscene_leaf_area: the total scene leaf area\n\nOutputs\n\naPPFD: absorbed Photosynthetic Photon Flux Density in mol[PAR] plant⁻¹ s⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"api/#XPalm.Models.SexDetermination","page":"XPalm API","title":"XPalm.Models.SexDetermination","text":"SexDetermination(TT_flowering, duration_abortion, duration_sex_determination, sex_ratio_min, sex_ratio_ref, rng)\nSexDetermination(TT_flowering, duration_abortion, duration_sex_determination, sex_ratio_min, sex_ratio_ref; random_seed=1)\n\nDetermines the sex of a phytomer -or rather, its bunch- based on the trophic  state of the plant during a given period in thermal time.\n\nArguments\n\nTT_flowering: thermal time for flowering since phytomer appearence (degree days).\nduration_abortion: duration used for computing abortion rate before flowering (degree days).\nduration_sex_determination: duration used for sex determination before the abortion period(degree days).\nsex_ratio_min: minimum allowed threshold of the sex ratio.\nsex_ratio_ref: reference threshold of the sex ratio, i.e. the value when the trophic status is 1 (offer=demand).\nrng: random number generator, Random.MersenneTwister by default.\nrandom_seed: random seed for the random number generator, 1 by default.\n\nInputs\n\ncarbon_offer_plant: carbon offer at the plant scale (usually after maintenance respiration) (gC/plant).\ncarbon_demand_plant: total carbon demand of the plant (gC/plant), used to compute the plant trophic status.\n\nOutputs\n\nsex: the sex of the phytomer (or bunch) (\"undetermined\", \"Female\" or \"Male\").\ncarbon_demand_sex_determination: carbon demand of the plant integrated over the period of sex determination (gC/plant)\ncarbon_offer_sex_determination: carbon offer of the plant integrated over the period of sex determination (gC/plant)\n\nNote\n\nThe sex of the organ is determined at TT_flowering-duration_abortion based on the trophic_status of the plant during a period of time  before this date. The hypothesis is that a trophic stress can trigger more males in the plant.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlantSimEngine.run!","page":"XPalm API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants = Constants())\n\nComputes the light interception of an object using the Beer-Lambert law.\n\nArguments\n\n::Beer: a Beer model, from the model list (i.e. m.light_interception)\nmodels: A ModelList struct holding the parameters for the model with\n\ninitialisations for lai (m² m⁻²): the leaf area index.\n\nstatus: the status of the model, usually the model list status (i.e. m.status)\nmeteo: meteorology structure, see Atmosphere\nconstants = PlantMeteo.Constants(): physical constants. See PlantMeteo.Constants for more details\n\nExamples\n\nusing PlantSimEngine, PlantBiophysics, PlantMeteo\nm = ModelList(light_interception=Beer(0.5), status=(lai=2.0,))\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\nm[:aPPFD]\n\n\n\n\n\n","category":"function"},{"location":"api/#PlantSimEngine.run!-2","page":"XPalm API","title":"PlantSimEngine.run!","text":"Compute root growth\n\nArguments\n\nm: root growth model\nftsw:  fraction of transpirable soil water (unitless [0:1])\nTEff:  daily efficient temperature for plant growth (degree C days) \n\nOutputs\n\nroot_depth: root depth (cm)\n\n\n\n\n\n","category":"function"},{"location":"api/#PlantSimEngine.run!-Tuple{XPalm.Models.PhytomerEmission, Vararg{Any, 5}}","page":"XPalm API","title":"PlantSimEngine.run!","text":"add_phytomer!(palm, initiation_age)\n\nAdd a new phytomer to the palm\n\nArguments\n\npalm: a Palm\ninitiation_age::Dates.Date: date of initiation of the phytomer \n\n\n\n\n\n","category":"method"},{"location":"api/#PlantSimEngine.run!-Tuple{XPalm.Models.ReproductiveOrganEmission, Vararg{Any, 5}}","page":"XPalm API","title":"PlantSimEngine.run!","text":"add_reproductive_organ!(...)\n\nAdd a new reproductive organ to a phytomer.\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.Models.KS-Tuple{Any, Any}","page":"XPalm API","title":"XPalm.Models.KS","text":"KS(fillRate, tresh)\n\nCoefficient of stress. \n\nArguments\n\nfillRate: fill level of the compartment\ntresh: filling treshold of the  compartment below which there is a reduction in the flow\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.Models.KS_bp-Tuple{Any, Any}","page":"XPalm API","title":"XPalm.Models.KS_bp","text":"KS_bp(fillRate, tresh)\n\nCoefficient of stress. \n\nArguments\n\nfillRate: fill level of the compartment\ntresh: filling treshold of the compartment below which there is a reduction in the flow\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.Models.compute_compartment_size-Tuple{Any, Any}","page":"XPalm API","title":"XPalm.Models.compute_compartment_size","text":"compute_compartment_size(m, root_depth)\n\nCompute the size of the layers of the FTSW model.\n\nArguments\n\nm: FTSW model\nroot_depth: depth of the root system\n\nReturns\n\nSizeC1: size of the evapotranspirable water layer in the first soil layer (mm)\nSizeVap: size of the evaporative layer within the first layer (mm)\nSizeC1minusVap: size of the transpirable layer within the first layer (SizeC1-SizeVap)\nSizeC2: size of the transpirable water layer in the first soil layer (mm)\nSizeC: size of transpirable soil water (mm) (SizeC2 + SizeC1minusVap)\n\n\n\n\n\n","category":"method"},{"location":"api/#XPalm.Models.compute_compartment_size-Tuple{XPalm.Models.FTSW_BP, Any}","page":"XPalm API","title":"XPalm.Models.compute_compartment_size","text":"compute_compartment_size(m, root_depth)\n\nCompute the size of the layers of the FTSW model.\n\nArguments\n\nm: FTSW model\nroot_depth: depth of the root system\n\nReturns\n\nSizeC1: size of the evapotranspirable water layer in the first soil layer (mm)\nSizeVap: size of the evaporative layer within the first layer (mm)\nSizeC1minusVap: size of the transpirable layer within the first layer (SizeC1-SizeVap)\nSizeC2: size of the transpirable water layer in the first soil layer (mm)\nSizeC: size of transpirable soil water (mm) (SizeC2 + SizeC1minusVap)\n\n\n\n\n\n","category":"method"},{"location":"vpalm/reconstruction/#Using-VPalm-to-reconstruct-a-Palm-Tree","page":"Reconstruction","title":"Using VPalm to reconstruct a Palm Tree","text":"","category":"section"},{"location":"vpalm/reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The package also includes a submodule VPalm that is an automaton that builds 3d mockups of palm plants from architectural parameters and allometric equations. It also integrates a biomechanical model to compute the leaf bending and torsion using the biomass of each leaf.","category":"page"},{"location":"vpalm/reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"You can run VPalm simply by loading the submodule. Here is an example to load VPalm default parameters and build a palm tree with a multiscale architecture defined using the Multiscale Tree Graph format (MTG).","category":"page"},{"location":"vpalm/reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"using XPalm\nusing XPalm.VPalm\nusing PlantGeom, CairoMakie\n\n# Load example parameters\nfile = joinpath(dirname(dirname(pathof(XPalm))), \"test\", \"references\", \"vpalm-parameter_file.yml\")\nparameters = read_parameters(file)\n\nmtg = build_mockup(parameters)\n\nplantviz(mtg, color = :green)","category":"page"},{"location":"vpalm/reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"(Image: palm plant)","category":"page"},{"location":"vpalm/reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"details: Code to reproduce this image\nTo reproduce the image above, you can use the following code snippet. It will create a mockup of a palm plant with colored segments based on their type.using XPalm\nusing XPalm.VPalm\nusing PlantGeom, CairoMakie\n\nfile = joinpath(dirname(dirname(pathof(XPalm))), \"test\", \"references\", \"vpalm-parameter_file.yml\")\nparameters = read_parameters(file)\nmtg = build_mockup(parameters; merge_scale=:leaflet)\ntraverse!(mtg) do node\n    if symbol(node) == \"Petiole\"\n        petiole_and_rachis_segments = descendants(node, symbol=[\"PetioleSegment\", \"RachisSegment\"])\n        colormap = cgrad([colorant\"peachpuff4\", colorant\"blanchedalmond\"], length(petiole_and_rachis_segments), scale=:log2)\n        for (i, seg) in enumerate(petiole_and_rachis_segments)\n            seg[:color_type] = colormap[i]\n        end\n    elseif symbol(node) == \"Leaflet\"\n        node[:color_type] = :mediumseagreen\n    elseif symbol(node) == \"Leaf\" # This will color the snags\n        node[:color_type] = :peachpuff4\n    end\nend\nf, ax, p = plantviz(mtg, color=:color_type)\nsave(\"palm_mockup.png\", f, size=(800, 600), px_per_unit=3)","category":"page"},{"location":"vpalm/reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"note: Note\nNote that the MTG is built with the following scales: [\"Plant\", \"Stem\", \"Phytomer\", \"Internode\", \"Leaf\", \"Petiole\", \"PetioleSegment\", \"Rachis\", \"RachisSegment\", \"Leaflet\", \"LeafletSegment\"].","category":"page"},{"location":"vpalm/parameters/#VPalm-Parameters","page":"Parameters","title":"VPalm Parameters","text":"","category":"section"},{"location":"vpalm/parameters/","page":"Parameters","title":"Parameters","text":"VPalm is a submodule of XPalm that provides a set of functions to reconstruct the architecture of palm trees based on a set of parameters and allometric relations.","category":"page"},{"location":"vpalm/parameters/","page":"Parameters","title":"Parameters","text":"Parameters are defined in a YAML file and a template is provided:","category":"page"},{"location":"vpalm/parameters/","page":"Parameters","title":"Parameters","text":"using XPalm.VPalm\nfile = joinpath(dirname(dirname(pathof(XPalm))), \"test\", \"references\", \"vpalm-parameter_file.yml\")\nparameters = read_parameters(file)","category":"page"},{"location":"vpalm/parameters/#Parameters-definition","page":"Parameters","title":"Parameters definition","text":"","category":"section"},{"location":"vpalm/parameters/","page":"Parameters","title":"Parameters","text":"Here is a list of all necessary parameters to run XPalm.VPalm:","category":"page"},{"location":"vpalm/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Value Description\nseed 0 Seed for random number generation\nnb_leaves_emitted 145 Number of leaves emitted since the seed\nnb_internodes_before_planting 20 Number of internodes before planting (estimation)\nnb_leaves_in_sheath 8 Number of leaves in the sheath (rank <1)\nphyllotactic_angle_mean 136.67 Frond phyllotactic angle mean (°)\nphyllotactic_angle_sd 0.48 Frond phyllotactic angle standard deviation (°)\ninitial_stem_height 0.05 Stem height at planting (m)\nstem_height_coefficient 0.018 Coefficient used in the computation of stem height\ninternode_length_at_maturity 0.03 Growth in stem height per leaf (~internode length) at adult stage (m)\nstem_growth_start 120 Number of leaves emitted when stem starts to grow in height\nstem_height_variation 0.50 Variation in stem height (m, never > 30% of stem height)\nstem_bending_mean 0 Average stem bending\nstem_bending_sd 0 Standard deviation around mean stem bending\nstem_diameter_max 0.77 Maximum stem diameter (m)\nstem_diameter_slope 0.007 Slope of the logit function for stem diameter\nstem_diameter_inflection 1.69 Inflection point of the logit function for stem diameter\nstem_diameter_residual 0.063 Residual of stem diameter (m)\nstem_diameter_snag 0.3 Diameter of stem considered as snag (m)\nstem_base_shrinkage 0.1 Shrinkage at stem base (smaller = sharper)\nstem_top_shrinkage 0.3 Shrinkage at stem top (smaller = sharper)\ninternode_rank_no_expansion 9 Rank of internode where expansion stops\ninternode_final_length 0.01 Length of internode around apical meristem (m)\nleaf_max_angle 90 Maximum angle of the leaf (°)\nleaf_slope_angle 0.05 Slope of leaf angle for logistic function\nleaf_inflection_angle 40 Inflection point of leaf angle for logistic function\ncpoint_decli_intercept 10.47 Intercept of linear regression of c-point declination\ncpoint_decli_slope 1.33 Slope of linear regression of c-point declination\ncpoint_angle_SDP 5.32 Standard deviation of c-point angle\nrachis_twist_initial_angle 4.0 Initial twist angle of rachis\nrachis_twist_initial_angle_sdp 0.0 Standard deviation of initial twist angle of rachis\npetiole_rachis_ratio_mean 0.25 Mean ratio of petiole length to rachis length\npetiole_rachis_ratio_sd 0.033 Standard deviation of petiole to rachis length ratio\npetiole_nb_segments 15 Number of segments in the petiole\nrachis_nb_segments 100 Number of segments in the rachis\nleafLengthIntercept 351.20 Intercept for leaf length calculation\nleafLengthSlope 0.058 Slope for leaf length calculation\nrachisLength_SDP 15.25 Standard deviation of rachis length\nrachis_fresh_weight [array] Fresh weight of rachis (g) for each leaf\nleaf_length_intercept 0.0 Intercept of the linear relationship between rachis length and biomass (m) (optional, can use rachis_final_lengths instead)\nleaf_length_slope 1.31 Slope of the linear relationship between rachis length and biomass (m/kg) (optional, can use rachis_final_lengths instead)\nrachis_final_lengths [array] Final rachis lengths (m) from oldest to rank 1 leaf (optional, can use leaf_length_intercept + leaf_length_slope instead)\nleaflet_lamina_angle 140 V-shape angle of leaflet (°)\nleaflets_nb_max 171.72 Maximum number of leaflets on a leaf\nleaflets_nb_min 20 Minimum number of leaflets on a leaf\nleaflets_nb_slope 0.25 Slope of logistic relationship between rachis length and nb leaflets\nleaflets_nb_inflexion 2.33 Inflection point of logistic relationship (rachis length vs nb leaflets)\nnbLeaflets_SDP 6 Standard deviation around computed value for given rachis length\nleaflet_position_shape_coefficient 2.48 Shape coefficient for placing leaflets along rachis\nleaflets_between_to_within_group_ratio 2.0 Ratio of inter-group to intra-group leaflets spacing\nrelative_position_bpoint 0.66 Relative position of b-point\nrelative_position_bpoint_sd 0.034 Standard deviation of relative position of b-point\nleaflet_length_at_b_intercept 0.61 Intercept of leaflet length at b-point (m)\nleaflet_length_at_b_slope 0.054 Slope of leaflet length at b-point\nleaflet_width_at_b_intercept 0.063 Intercept of leaflet width at b-point\nleaflet_width_at_b_slope -0.004 Slope of leaflet width at b-point\nrelative_length_first_leaflet 0.18 Relative length of first leaflet\nrelative_length_last_leaflet 0.52 Relative length of last leaflet\nrelative_position_leaflet_max_length 0.52 Relative position of leaflet with maximum length\nrelative_width_first_leaflet 0.22 Relative width of first leaflet\nrelative_width_last_leaflet 0.53 Relative width of last leaflet\nrelative_position_leaflet_max_width 0.61 Relative position of leaflet with maximum width\nleaflet_xm_intercept 0.18 Base value for xm (position of maximum width) for leaflets\nleaflet_xm_slope 0.08 How much xm changes per unit of relative position along rachis\nleaflet_ym_intercept 0.51 Base value for relative width at maximum width position\nleaflet_ym_slope -0.025 How much relative width changes per unit of position along rachis\nleaflet_axial_angle_c 78.22 Leaflet axial angle parameter c\nleaflet_axial_angle_a 10.43 Leaflet axial angle parameter a\nleaflet_axial_angle_slope -4.69 Leaflet axial angle slope\nleaflet_axial_angle_sdp 8.06 Standard deviation of leaflet axial angle\nleaflet_stiffness 1500 Leaflet stiffness\nleaflet_stiffness_sd 7000 Standard deviation of leaflet stiffness\nleaflet_frequency_high [array] Frequency of high position leaflets along 10 rachis sub-sections\nleaflet_frequency_low [array] Frequency of low position leaflets along 10 rachis sub-sections\nnbInflorescences 0 Number of inflorescences\nleaf_base_width 0.3 Width of leaf base (m)\ncpoint_width_intercept 0.01 Rachis width at c-point intercept for linear interpolation (m)\ncpoint_width_slope 0.012 Rachis width at c-point slope for linear interpolation\nrachis_width_tip 0.03 Width at tip of rachis (m)\nleaf_base_height 0.1 Height of leaf base (m)\ncpoint_height_width_ratio 0.57 Height to width ratio at c-point\nheight_rachis_tappering -0.93 Tapering factor for rachis height\nleaflet_radial_high_a0_sup 26.30 Upper bound of leaflet angle at position 0 for high position leaflets\nleaflet_radial_high_amax_sup 60.49 Upper bound of maximum angle for high position leaflets\nleaflet_radial_high_a0_inf 16.66 Lower bound of angle at position 0 for high position leaflets\nleaflet_radial_high_amax_inf 9.08 Lower bound of maximum angle for high position leaflets\nleaflet_radial_low_a0_sup -7.91 Upper bound of angle at position 0 for low position leaflets\nleaflet_radial_low_amax_sup -4.83 Upper bound of maximum angle for low position leaflets\nleaflet_radial_low_a0_inf -12.29 Lower bound of angle at position 0 for low position leaflets\nleaflet_radial_low_amax_inf -34.33 Lower bound of maximum angle for low position leaflets\nelastic_modulus 2221.67 Elastic modulus for biomechanical calculations\nshear_modulus 68.20 Shear modulus for biomechanical calculations","category":"page"},{"location":"vpalm/parameters/#Biomechanical-Model-Parameters","page":"Parameters","title":"Biomechanical Model Parameters","text":"","category":"section"},{"location":"vpalm/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Value Description\nnb_sections 100 Number of sections for discretizing constant form sections\nangle_max 21.0 Maximum flexion and torsion angles between sections (°)\niterations 15 Number of iterations for recursive computation","category":"page"},{"location":"api_index/#XPalm-API","page":"Index","title":"XPalm API","text":"","category":"section"},{"location":"api_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"running/#Programmatically-running-the-model","page":"Running XPalm","title":"Programmatically running the model","text":"","category":"section"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"Run a simple simulation using default parameters and meteorological data:","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"using XPalm, CSV, DataFrames\n\n# Load example meteorological data\nmeteo = CSV.read(joinpath(dirname(dirname(pathof(XPalm))), \"0-data/meteo.csv\"), DataFrame)\n\n# Run simulation\ndf = xpalm(meteo, DataFrame;\n    vars = Dict(\"Scene\" => (:lai,)), # Request LAI as output\n)","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"note: Note\nYou need to install the CSV and DataFrames packages to run the example above. You can install them by running ] add CSV DataFrames.","category":"page"},{"location":"running/#Advanced-Usage","page":"Running XPalm","title":"Advanced Usage","text":"","category":"section"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"Customize palm parameters and request multiple outputs:","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"# Read the parameters from a YAML file (provided in the example folder of the package).\nusing YAML\nparameters = YAML.load_file(joinpath(dirname(dirname(pathof(XPalm))), \"examples/xpalm_parameters.yml\"))\n\n# Load example meteorological data\nmeteo = CSV.read(joinpath(dirname(dirname(pathof(XPalm))), \"0-data/meteo.csv\"), DataFrame)\n\n# Create palm with custom parameters\np = XPalm.Palm(parameters=parameters)\n\n# Run simulation with multiple outputs\nresults = xpalm(\n    meteo,\n    DataFrame,\n    vars = Dict(\n        \"Scene\" => (:lai,),\n        \"Plant\" => (:leaf_area, :biomass_bunch_harvested),\n        \"Soil\" => (:ftsw,)\n    ),\n    palm = p,\n)","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"You can also import the parameters from a JSON file using the JSON package:","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"using JSON # You first need to install the JSON package by running `] add JSON`\nparams = open(joinpath(dirname(dirname(pathof(XPalm))), \"examples/xpalm_parameters.json\"), \"r\") do io\n    JSON.parse(io; dicttype=Dict{String,Any}, inttype=Int64)\nend","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"note: Note\nThe configuration file must contain all the parameters required by the model. Template files are available from the examples folder.","category":"page"},{"location":"running/#Importing-the-models","page":"Running XPalm","title":"Importing the models","text":"","category":"section"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"The models are available from the Models submodule. To import all models, you can use the following command:","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"using XPalm\nusing XPalm.Models","category":"page"},{"location":"running/#More-examples","page":"Running XPalm","title":"More examples","text":"","category":"section"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"The package provides an example script in the examples folder. To run it, you first have to place your working directory inside the folder, and then activate its environement by running ] activate ..","category":"page"},{"location":"running/","page":"Running XPalm","title":"Running XPalm","text":"You can also find example applications in the Xpalm applications Github repository.","category":"page"},{"location":"#XPalm-A-growth-and-yield-model-for-oil-palm","page":"Home","title":"XPalm - A growth and yield model for oil palm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<!-- [![Stable](https://img.shields.io/badge/docs-stable-blue.svg)](https://PalmStudio.github.io/XPalm.jl/stable/) -->","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"XPalm is a growth and yield model for oil palm (Elaeis guineensis).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XPalm is a process-based model for simulating oil palm (Elaeis guineensis) growth and development. The model simulates key physiological processes including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Phenology and development\nCarbon assimilation and allocation\nWater balance\nReproductive organ development\nYield components","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: XPalm diagram)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 1. Simplified diagram of the component models used in XPalm. The numbering is associated to the computational flow, from the first models to execute to the last.","category":"page"},{"location":"","page":"Home","title":"Home","text":"XPalm implements a multiscale approach, modeling processes at different organizational levels:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scene: Environment and canopy-level processes Plant: Whole palm processes Phytomer: Individual growth unit processes Organ: Leaf, internode and reproductive organ processes","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model uses a daily time step and requires standard meteorological inputs (temperature, radiation, rainfall...).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model also includes a submodule VPalm to design palm tree mockups from a set of architectural parameters and allometric equations. It is designed to integrate smoothly with the physiological models from the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model is implemented in the Julia programming language, which is a high-level, high-performance dynamic programming language for technical computing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: palm plant)","category":"page"},{"location":"#Example-outputs","page":"Home","title":"Example outputs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here are some example outputs from the model, showing the evolution of variables at different scales:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scene level:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Leaf area index (LAI) at the scene level over time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: scene level)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plant level:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Maintenance respiration (Rm), absorbed PPFD (aPPFD), biomass of bunches harvested, and leaf area at the plant level over time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: plant level)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Leaf level:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Leaf area at the level of the individual leaf over time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: leaf level)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Soil level:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fraction of transpirable soil water (FTSW) over time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: soil level)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install XPalm using Julia's package manager, typing ] in the Julia REPL (i.e. the console) to enter the Pkg REPL mode and then typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add XPalm","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, type the following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using XPalm","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the PalmStudio research project, funded by the SMART Research Institute and CIRAD.","category":"page"},{"location":"notebook/#Running-XPalm-using-a-notebook","page":"XPalm notebook","title":"Running XPalm using a notebook","text":"","category":"section"},{"location":"notebook/","page":"XPalm notebook","title":"XPalm notebook","text":"The easiest way to run the model is to use the template notebook provided by the package. To run the notebook, you need to install the Pluto package first by running ] add Pluto. Then, you can run the notebook using the following commands in the Julia REPL:","category":"page"},{"location":"notebook/","page":"XPalm notebook","title":"XPalm notebook","text":"using Pluto, XPalm\nXPalm.notebook(\"xpalm_notebook.jl\")","category":"page"},{"location":"notebook/","page":"XPalm notebook","title":"XPalm notebook","text":"This command will create a new Pluto notebook (named \"xpalm_notebook.jl\") in the current directory, and open it automatically for you.","category":"page"},{"location":"notebook/","page":"XPalm notebook","title":"XPalm notebook","text":"Once closed, you can re-open this notebook by running the same command again. If the file already exists, it will be opened automatically.","category":"page"},{"location":"coupling/#Coupling-XPalm-and-VPalm","page":"Coupling","title":"Coupling XPalm and VPalm","text":"","category":"section"},{"location":"coupling/","page":"Coupling","title":"Coupling","text":"When studying the growth and yield of palm trees, you might want to be able to dynamicaly reconstruct the architecture of the palm tree based on its growth and physiological parameters. This is where the coupling of XPalm and VPalm submodule comes into play.","category":"page"},{"location":"coupling/#Coupling-example","page":"Coupling","title":"Coupling example","text":"","category":"section"}]
}
